<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>java基础</title><meta name="author" content="郑 则弘"><meta name="copyright" content="郑 则弘"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.JAVA基础1.JAVA中的几种基本类型，各占用多少字节？ 下图单位是bit,非字节 1B&#x3D;8bit  2.String能被继承吗？为什么？不可以，因为String类有final修饰符，而final修饰的类是不能被继承的，实现细节不允许改变。平常我们定义的String str&#x3D;”abc”(直接赋一个字面量);其实和String str&#x3D;new String(“ab">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础">
<meta property="og:url" content="https://myzzh1231.github.io/zzhBlog.github.io/2023/03/09/1.JAVA%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="zzhBlog">
<meta property="og:description" content="1.JAVA基础1.JAVA中的几种基本类型，各占用多少字节？ 下图单位是bit,非字节 1B&#x3D;8bit  2.String能被继承吗？为什么？不可以，因为String类有final修饰符，而final修饰的类是不能被继承的，实现细节不允许改变。平常我们定义的String str&#x3D;”abc”(直接赋一个字面量);其实和String str&#x3D;new String(“ab">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myzzh1231.github.io/zzhBlog.github.io/images/background.jpg">
<meta property="article:published_time" content="2023-03-09T06:49:42.063Z">
<meta property="article:modified_time" content="2023-03-09T06:57:06.892Z">
<meta property="article:author" content="郑 则弘">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myzzh1231.github.io/zzhBlog.github.io/images/background.jpg"><link rel="shortcut icon" href="/zzhBlog.github.io/img/favicon.png"><link rel="canonical" href="https://myzzh1231.github.io/zzhBlog.github.io/2023/03/09/1.JAVA%E5%9F%BA%E7%A1%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/zzhBlog.github.io/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/zzhBlog.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 郑 则弘","link":"链接: ","source":"来源: zzhBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://fastly.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-09 14:57:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="is-center"><div class="avatar-img"><img src="/zzhBlog.github.io/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">郑 则弘</div><div class="author-info__description"></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chenxz21/bcxm" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/zzhBlog.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/zzhBlog.github.io/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/zzhBlog.github.io/shuoba"><i class="fa-fw fas fa-comment-dots"></i><span> 说吧</span></a></div><div class="menus_item"><a class="site-page" href="/zzhBlog.github.io/gedan"><i class="fa-fw fas fa-music"></i><span> 歌单</span></a></div><div class="menus_item"><a class="site-page" href="/zzhBlog.github.io/game"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page" href="/zzhBlog.github.io/artitalk"><i class="fa-fw fa fa-heartbeat"></i><span> 时光</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/zzhBlog.github.io/google"><span> 镜像</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://json.xbyzs.cf"><span> Json格式化</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://draw.xbyzs.cf"><span> Draw画布</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://enkey.xbyzs.cf"><span> EnKey</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/zzhBlog.github.io/">zzhBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/zzhBlog.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/zzhBlog.github.io/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/zzhBlog.github.io/shuoba"><i class="fa-fw fas fa-comment-dots"></i><span> 说吧</span></a></div><div class="menus_item"><a class="site-page" href="/zzhBlog.github.io/gedan"><i class="fa-fw fas fa-music"></i><span> 歌单</span></a></div><div class="menus_item"><a class="site-page" href="/zzhBlog.github.io/game"><i class="fa-fw fas fa-gamepad"></i><span> 游戏</span></a></div><div class="menus_item"><a class="site-page" href="/zzhBlog.github.io/artitalk"><i class="fa-fw fa fa-heartbeat"></i><span> 时光</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tools"></i><span> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/zzhBlog.github.io/google"><span> 镜像</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://json.xbyzs.cf"><span> Json格式化</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://draw.xbyzs.cf"><span> Draw画布</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://enkey.xbyzs.cf"><span> EnKey</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-03-09T06:49:42.063Z" title="发表于 2023-03-09 14:49:42">2023-03-09</time></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h1 id="1-JAVA基础"><a href="#1-JAVA基础" class="headerlink" title="1.JAVA基础"></a>1.JAVA基础</h1><h2 id="1-JAVA中的几种基本类型，各占用多少字节？"><a href="#1-JAVA中的几种基本类型，各占用多少字节？" class="headerlink" title="1.JAVA中的几种基本类型，各占用多少字节？"></a>1.JAVA中的几种基本类型，各占用多少字节？</h2><p><img src="https://img-blog.csdn.net/20170825174535388?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDA0MjA2Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="è¿éåå¾çæè¿°"></p>
<p>下图单位是bit,非字节 1B&#x3D;8bit</p>
<p><img src="https://img-blog.csdnimg.cn/20190714224935794.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ5NTM5MA==,size_16,color_FFFFFF,t_70" alt="å¨è¿éæå¥å¾çæè¿°"></p>
<h2 id="2-String能被继承吗？为什么？"><a href="#2-String能被继承吗？为什么？" class="headerlink" title="2.String能被继承吗？为什么？"></a>2.String能被继承吗？为什么？</h2><p>不可以，因为String类有final修饰符，而final修饰的类是不能被继承的，实现细节不允许改变。平常我们定义的String str&#x3D;”abc”(直接赋一个字面量);其实和String str&#x3D;new String(“abc”)(通过构造器构造)还是有差异的。</p>
<p><img src="https://img-blog.csdnimg.cn/20200412234359327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ5NTM5MA==,size_16,color_FFFFFF,t_70" alt="å¨è¿éæå¥å¾çæè¿°"></p>
<h3 id="String-str-x3D-“abc”和String-str-x3D-new-String-“abc”-产生几个对象？"><a href="#String-str-x3D-“abc”和String-str-x3D-new-String-“abc”-产生几个对象？" class="headerlink" title="String str&#x3D;“abc”和String str&#x3D;new String(“abc”); 产生几个对象？"></a>String str&#x3D;“abc”和String str&#x3D;new String(“abc”); 产生几个对象？</h3><p>​    1.前者1或0，后者2或1，先看字符串常量池，如果字符串常量池中没有，都在常量池中创建一个，如果有，前者直接引用，后者在堆内存中还需创建一个“abc”实例对象。<br>​	2.对于基础类型的变量和常量：变量和引用存储在栈中，常量存储在常量池中。<br>​	3.为了提升jvm（JAVA虚拟机）性能和减少内存开销，避免字符的重复创建 项目中还是不要使用new String去创建字符串，最好使用String直接赋值。</p>
<p>参考链接</p>
<h2 id="3-String，-Stringbuffer，-StringBuilder-的区别。"><a href="#3-String，-Stringbuffer，-StringBuilder-的区别。" class="headerlink" title="3.String， Stringbuffer， StringBuilder 的区别。"></a>3.String， Stringbuffer， StringBuilder 的区别。</h2><p>String 字符串常量(final修饰，不可被继承)，<strong>String是常量</strong>，当创建之后即不能更改。(可以通过StringBuffer和StringBuilder创建String对象(常用的两个字符串操作类)。)<br>&#x3D;&#x3D;StringBuffer 字符串变量（线程安全）,&#x3D;&#x3D;其也是final类别的，不允许被继承，其中的绝大多数方法都进行了同步处理，包括常用的Append方法也做了同步处理(synchronized修饰)。其自jdk1.0起就已经出现。其toString方法会进行对象缓存，以减少元素复制开销。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (toStringCache == <span class="literal">null</span>) &#123;</span><br><span class="line">		toStringCache = Arrays.copyOfRange(value, <span class="number">0</span>, count);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(toStringCache, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>&#x3D;&#x3D;StringBuilder 字符串变量（非线程安全）&#x3D;&#x3D;其自jdk1.5起开始出现。与StringBuffer一样都继承和实现了同样的接口和类，方法除了没使用synch修饰以外基本一致，不同之处在于最后toString的时候，会直接返回一个新对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// Create a copy, don’t share the array</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-ArrayList-和-LinkedList-有什么区别。"><a href="#4-ArrayList-和-LinkedList-有什么区别。" class="headerlink" title="4.ArrayList 和 LinkedList 有什么区别。"></a>4.ArrayList 和 LinkedList 有什么区别。</h2><h3 id="ArrayList和LinkedList都实现了List接口，有以下的不同点："><a href="#ArrayList和LinkedList都实现了List接口，有以下的不同点：" class="headerlink" title="ArrayList和LinkedList都实现了List接口，有以下的不同点："></a>ArrayList和LinkedList都实现了List接口，有以下的不同点：</h3><p>1、ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。<br>2、相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。<br>3、LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</p>
<h2 id="5-讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当-new-的时候，-他们的执行顺序。"><a href="#5-讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当-new-的时候，-他们的执行顺序。" class="headerlink" title="5.讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当 new 的时候， 他们的执行顺序。"></a>5.讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当 new 的时候， 他们的执行顺序。</h2><p>此题考察的是类加载器实例化时进行的操作步骤（加载–&gt;连接-&gt;初始化）。<br>父类静态代变量、<br>父类静态代码块、<br>子类静态变量、<br>子类静态代码块、<br>父类非静态变量（父类实例成员变量）、<br>父类构造函数、<br>子类非静态变量（子类实例成员变量）、<br>子类构造函数。<br>测试demo<br>参阅博客《深入理解类加载》</p>
<h2 id="6-用过哪些-Map-类，都有什么区别，HashMap-是线程安全的吗-并发下使用的-Map-是什么，他们内部原理分别是什么，比如存储方式，-hashcode，扩容，-默认容量等。"><a href="#6-用过哪些-Map-类，都有什么区别，HashMap-是线程安全的吗-并发下使用的-Map-是什么，他们内部原理分别是什么，比如存储方式，-hashcode，扩容，-默认容量等。" class="headerlink" title="6.用过哪些 Map 类，都有什么区别，HashMap 是线程安全的吗,并发下使用的 Map 是什么，他们内部原理分别是什么，比如存储方式， hashcode，扩容， 默认容量等。"></a>6.用过哪些 Map 类，都有什么区别，HashMap 是线程安全的吗,并发下使用的 Map 是什么，他们内部原理分别是什么，比如存储方式， hashcode，扩容， 默认容量等。</h2><p>hashMap是线程不安全的，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，采用哈希表来存储的，<br>参考链接<br>JAVA8 的 ConcurrentHashMap 为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。<br>参考链接</p>
<h2 id="7-有没有有顺序的-Map-实现类，-如果有，-他们是怎么保证有序的。"><a href="#7-有没有有顺序的-Map-实现类，-如果有，-他们是怎么保证有序的。" class="headerlink" title="7.有没有有顺序的 Map 实现类， 如果有， 他们是怎么保证有序的。"></a>7.有没有有顺序的 Map 实现类， 如果有， 他们是怎么保证有序的。</h2><p>TreeMap和LinkedHashMap是有序的（TreeMap默认升序，LinkedHashMap则记录了插入顺序）。<br>参考链接</p>
<h2 id="8-抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么。"><a href="#8-抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么。" class="headerlink" title="8.抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。"></a>8.抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。</h2><p>1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。<br>2、抽象类要被子类继承，接口要被类实现。<br>3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现<br>4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。<br>5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。<br>6、抽象方法只能申明，不能实现。abstract void abc();不能写成abstract void abc(){}。<br>7、抽象类里可以没有抽象方法<br>8、如果一个类里有抽象方法，那么这个类只能是抽象类<br>9、抽象方法要被实现，所以不能是静态的，也不能是私有的。<br>10、接口可继承接口，并可多继承接口，但类只能单根继承。</p>
<h2 id="9-继承和聚合的区别在哪。"><a href="#9-继承和聚合的区别在哪。" class="headerlink" title="9.继承和聚合的区别在哪。"></a>9.继承和聚合的区别在哪。</h2><p>继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；在Java中此类关系通过关键字extends明确标识，在设计时一般没有争议性；</p>
<p>聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；比如计算机与CPU、公司与员工的关系等；表现在代码层面，和关联关系是一致的，只能从语义级别来区分；</p>
<p>参考链接</p>
<h2 id="10-讲讲你理解的-nio和-bio-的区别是啥，谈谈-reactor-模型。"><a href="#10-讲讲你理解的-nio和-bio-的区别是啥，谈谈-reactor-模型。" class="headerlink" title="10.讲讲你理解的 nio和 bio 的区别是啥，谈谈 reactor 模型。"></a>10.讲讲你理解的 nio和 bio 的区别是啥，谈谈 reactor 模型。</h2><p>IO(BIO)是面向流的，NIO是面向缓冲区的<br>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。<br>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。<br>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。<br>参考链接1<br>参考链接2</p>
<h2 id="11-反射的原理，反射创建类实例的三种方式是什么"><a href="#11-反射的原理，反射创建类实例的三种方式是什么" class="headerlink" title="11.反射的原理，反射创建类实例的三种方式是什么"></a>11.反射的原理，反射创建类实例的三种方式是什么</h2><p>参考链接1<br>参考链接2</p>
<h2 id="12-反射中，Class-forName-和-ClassLoader-区别。"><a href="#12-反射中，Class-forName-和-ClassLoader-区别。" class="headerlink" title="12.反射中，Class.forName 和 ClassLoader 区别。"></a>12.反射中，Class.forName 和 ClassLoader 区别。</h2><p>参考链接</p>
<h2 id="13-描述动态代理的几种实现方式，分别说出相应的优缺点。"><a href="#13-描述动态代理的几种实现方式，分别说出相应的优缺点。" class="headerlink" title="13.描述动态代理的几种实现方式，分别说出相应的优缺点。"></a>13.描述动态代理的几种实现方式，分别说出相应的优缺点。</h2><p>Jdk cglib jdk底层是利用反射机制，需要基于接口方式，这是由于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">target.getClass().getInterfaces(), <span class="built_in">this</span>);</span><br></pre></td></tr></table></figure>

<p>Cglib则是基于asm框架，实现了无反射机制进行代理，利用空间来换取了时间，代理效率高于jdk<br>参考链接<br>动态代理与 cglib 实现的区别<br>同上（基于invocationHandler和methodInterceptor）</p>
<h2 id="14-为什么-CGlib-方式可以对接口实现代理。"><a href="#14-为什么-CGlib-方式可以对接口实现代理。" class="headerlink" title="14.为什么 CGlib 方式可以对接口实现代理。"></a>14.为什么 CGlib 方式可以对接口实现代理。</h2><p>同上</p>
<h2 id="15-final-的用途"><a href="#15-final-的用途" class="headerlink" title="15.final 的用途"></a>15.final 的用途</h2><p>类、变量、方法<br>final 修饰的类叫最终类，该类不能被继承。<br>final 修饰的方法不能被重写。<br>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。<br>参考链接</p>
<h2 id="16-写出三种单例模式实现。"><a href="#16-写出三种单例模式实现。" class="headerlink" title="16.写出三种单例模式实现。"></a>16.写出三种单例模式实现。</h2><p>懒汉式单例，饿汉式单例，双重检查等<br>参考链接</p>
<h2 id="17-如何在父类中为子类自动完成所有的-hashcode-和-equals-实现？这么做有何优劣。"><a href="#17-如何在父类中为子类自动完成所有的-hashcode-和-equals-实现？这么做有何优劣。" class="headerlink" title="17.如何在父类中为子类自动完成所有的 hashcode 和 equals 实现？这么做有何优劣。"></a>17.如何在父类中为子类自动完成所有的 hashcode 和 equals 实现？这么做有何优劣。</h2><p>同时复写hashcode和equals方法，优势可以添加自定义逻辑，且不必调用超类的实现。<br>参考链接</p>
<h2 id="18-请结合-OO-设计理念，谈谈访问修饰符-public、private、protected、default-在应用设计中的作用。"><a href="#18-请结合-OO-设计理念，谈谈访问修饰符-public、private、protected、default-在应用设计中的作用。" class="headerlink" title="18.请结合 OO 设计理念，谈谈访问修饰符 public、private、protected、default 在应用设计中的作用。"></a>18.请结合 OO 设计理念，谈谈访问修饰符 public、private、protected、default 在应用设计中的作用。</h2><p>访问修饰符，主要标示修饰块的作用域，方便隔离防护</p>
<p>类中的数据成员和成员函数据具有的访问权限包括：public、private、protect、default（包访问权限）<br>作用域		当前类	同一package	子孙类	其他package<br>public   	√    	√         	√       √<br>protected   √      	√           √       ×<br>default     √       √           ×       ×<br>private     √       ×           ×       × </p>
<p>public           所有类可见<br>protected      	 本包和所有子类都可见（本包中的子类非子类均可访问，不同包中的子类可以访问，不是子类不能访问）<br>default          本包可见（即默认的形式）（本包中的子类非子类均可访问，不同包中的类及子类均不能访问）<br>priavte          本类可见<br>public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包（package）访问。<br>private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。<br>protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。<br>default：即不加任何访问修饰符，通常称为”默认访问模式”。该模式下，只允许在同一个包中进行访问。</p>
<h2 id="19-深拷贝和浅拷贝区别。"><a href="#19-深拷贝和浅拷贝区别。" class="headerlink" title="19.深拷贝和浅拷贝区别。"></a>19.深拷贝和浅拷贝区别。</h2><p>参考链接</p>
<h2 id="20-数组和链表数据结构描述，各自的时间复杂度"><a href="#20-数组和链表数据结构描述，各自的时间复杂度" class="headerlink" title="20.数组和链表数据结构描述，各自的时间复杂度"></a>20.数组和链表数据结构描述，各自的时间复杂度</h2><p>参考链接</p>
<h2 id="21-error-和-exception-的区别，CheckedException，RuntimeException-的区别"><a href="#21-error-和-exception-的区别，CheckedException，RuntimeException-的区别" class="headerlink" title="21.error 和 exception 的区别，CheckedException，RuntimeException 的区别"></a>21.error 和 exception 的区别，CheckedException，RuntimeException 的区别</h2><p>参考链接</p>
<h2 id="22-请列出-5-个运行时异常。"><a href="#22-请列出-5-个运行时异常。" class="headerlink" title="22.请列出 5 个运行时异常。"></a>22.请列出 5 个运行时异常。</h2><p>同上</p>
<h2 id="23-在自己的代码中，如果创建一个-java-lang-String-对象，这个对象是否可以被类加载器加载？为什么"><a href="#23-在自己的代码中，如果创建一个-java-lang-String-对象，这个对象是否可以被类加载器加载？为什么" class="headerlink" title="23.在自己的代码中，如果创建一个 java.lang.String 对象，这个对象是否可以被类加载器加载？为什么"></a>23.在自己的代码中，如果创建一个 java.lang.String 对象，这个对象是否可以被类加载器加载？为什么</h2><p>类加载无须等到“首次使用该类”时加载，jvm允许预加载某些类。。。。<br>参考链接</p>
<h2 id="24-说一说你对-java-lang-Object-对象中-hashCode-和-equals-方法的理解。在什么场景下需要重新实现这两个方法。"><a href="#24-说一说你对-java-lang-Object-对象中-hashCode-和-equals-方法的理解。在什么场景下需要重新实现这两个方法。" class="headerlink" title="24.说一说你对 java.lang.Object 对象中 hashCode 和 equals 方法的理解。在什么场景下需要重新实现这两个方法。"></a>24.说一说你对 java.lang.Object 对象中 hashCode 和 equals 方法的理解。在什么场景下需要重新实现这两个方法。</h2><p>参考上边试题(17)</p>
<h2 id="25-在-jdk1-5-中，引入了泛型，泛型的存在是用来解决什么问题。"><a href="#25-在-jdk1-5-中，引入了泛型，泛型的存在是用来解决什么问题。" class="headerlink" title="25.在 jdk1.5 中，引入了泛型，泛型的存在是用来解决什么问题。"></a>25.在 jdk1.5 中，引入了泛型，泛型的存在是用来解决什么问题。</h2><p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数，泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率<br>参考链接</p>
<h2 id="26-这样的-a-hashcode-有什么用，与-a-equals-b-有什么关系。"><a href="#26-这样的-a-hashcode-有什么用，与-a-equals-b-有什么关系。" class="headerlink" title="26.这样的 a.hashcode() 有什么用，与 a.equals(b)有什么关系。"></a>26.这样的 a.hashcode() 有什么用，与 a.equals(b)有什么关系。</h2><p>hashcode<br>hashcode（）方法提供了对象的hashCode值，是一个native方法，返回的默认值与System.identityHashCode(obj)一致。<br>通常这个值是对象头部的一部分二进制位组成的数字，具有一定的标识对象的意义存在，但绝不定于地址。<br>作用是：用一个数字来标识对象。比如在HashMap、HashSet等类似的集合类中，如果用某个对象本身作为Key，即要基于这个对象实现Hash的写入和查找，那么对象本身如何实现这个呢？就是基于hashcode这样一个数字来完成的，只有数字才能完成计算和对比操作。<br>hashcode是否唯一<br>hashcode只能说是标识对象，在hash算法中可以将对象相对离散开，这样就可以在查找数据的时候根据这个key快速缩小数据的范围，但hashcode不一定是唯一的，所以hash算法中定位到具体的链表后，需要循环链表，然后通过equals方法来对比Key是否是一样的。<br>equals与hashcode的关系<br>equals相等两个对象，则hashcode一定要相等。但是hashcode相等的两个对象不一定equals相等。<br>参考链接</p>
<h2 id="27-有没有可能-2-个不相等的对象有相同的-hashcode。"><a href="#27-有没有可能-2-个不相等的对象有相同的-hashcode。" class="headerlink" title="27.有没有可能 2 个不相等的对象有相同的 hashcode。"></a>27.有没有可能 2 个不相等的对象有相同的 hashcode。</h2><p>有<br>实例:</p>
<p>String str1 &#x3D; “通话”;<br>String str2 &#x3D; “重地”;<br>System.out.println(String.format(“str1：%d | str2：%d”,  str1.hashCode(),str2.hashCode()));<br>System.out.println(str1.equals(str2));</p>
<p>执行结果:str1：1179395 | str2：1179395<br>false</p>
<h2 id="28-Java-中的-HashSet-内部是如何工作的。"><a href="#28-Java-中的-HashSet-内部是如何工作的。" class="headerlink" title="28.Java 中的 HashSet 内部是如何工作的。"></a>28.Java 中的 HashSet 内部是如何工作的。</h2><p>底层是基于hashmap实现的<br>参考链接<br>什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。<br>参考链接</p>
<h2 id="29-JDK-和-JRE-有什么区别？"><a href="#29-JDK-和-JRE-有什么区别？" class="headerlink" title="29.JDK 和 JRE 有什么区别？"></a>29.JDK 和 JRE 有什么区别？</h2><p>JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。<br>JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。<br>具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。</p>
<h2 id="30-x3D-x3D-和-equals-的区别是什么？"><a href="#30-x3D-x3D-和-equals-的区别是什么？" class="headerlink" title="30.&#x3D;&#x3D; 和 equals 的区别是什么？"></a>30.&#x3D;&#x3D; 和 equals 的区别是什么？</h2><p>&#x3D;&#x3D; 解读:<br>对于基本类型和引用类型 &#x3D;&#x3D; 的作用效果是不同的，如下所示：<br>基本类型：比较的是值是否相同；<br>引用类型：比较的是引用是否相同；<br>实例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">y</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">System.out.println(x==y); <span class="comment">// true,引用相同</span></span><br><span class="line">System.out.println(x==z); <span class="comment">// false,==:string比较引用,开辟了新的堆内存空间,所以false</span></span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true,equals:string:比较值,相同</span></span><br><span class="line">System.out.println(x.equals(z)); <span class="comment">// true,equals:string比较值,相同</span></span><br></pre></td></tr></table></figure>

<p>equals 解读:<br>equals 本质上就是 &#x3D;&#x3D;，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。<br>首先来看默认情况下 equals 比较一个(有相同值的对象)，代码如下：</p>
<p>public class Cat {<br>    private  String name;<br>    public Cat(String name){<br>        this.name &#x3D; name;<br>    }<br>    public String getName() {<br>        return name;<br>    }<br>    public void setName(String name) {<br>        this.name &#x3D; name;<br>    }<br>    public static void main(String[] args) {<br>        Cat c1 &#x3D; new Cat(“cat1”);&#x2F;&#x2F;c1是Cat的实例化对象,c2同理<br>        Cat c2 &#x3D; new Cat(“cat2”);<br>           String s1 &#x3D; new String(“隔壁老王”);<br>        String s2 &#x3D; new String(“隔壁老王”);<br>        System.out.println(c1.equals(c2));&#x2F;&#x2F;false,equals在比较的类对象的时候比较的是引用<br>        System.out.println(s1.equals(s2)); &#x2F;&#x2F;true,而在比较string的时候,因为重写了equals方法,和基本数据类型一样,比较的是值,所以为true</p>
<p>}<br>总结 ：&#x3D;&#x3D; 对于基本类型来说是值比较(不难理解,八种基本数据类型是可以有确定值的)，对于引用类型来说是比较的是引用(数组、类、接口没有确定值)；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>
<h2 id="31-java-中的-Math-round-1-5-等于多少？"><a href="#31-java-中的-Math-round-1-5-等于多少？" class="headerlink" title="31.java 中的 Math.round(-1.5) 等于多少？"></a>31.java 中的 Math.round(-1.5) 等于多少？</h2><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。同理,Math.round(1.5) &#x3D; 2</p>
<h2 id="32-写一个字符串反转函数。"><a href="#32-写一个字符串反转函数。" class="headerlink" title="32.写一个字符串反转函数。"></a>32.写一个字符串反转函数。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringBuffer reverse</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">stringBuffer.append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System.out.println(stringBuffer.reverse()); <span class="comment">// gfedcba</span></span><br><span class="line"><span class="comment">// StringBuilder reverse</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">stringBuilder.append(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">System.out.println(stringBuilder.reverse()); <span class="comment">// gfedcba</span></span><br></pre></td></tr></table></figure>



<h2 id="33-String-类的常用方法都有那些？"><a href="#33-String-类的常用方法都有那些？" class="headerlink" title="33.String 类的常用方法都有那些？"></a>33.String 类的常用方法都有那些？</h2><p>indexOf()：返回指定字符的索引。<br>charAt()：返回指定索引处的字符。<br>replace()：字符串替换。<br>trim()：去除字符串两端空白。<br>split()：分割字符串，返回一个分割后的字符串数组。<br>getBytes()：返回字符串的 byte 类型数组。<br>length()：返回字符串长度。<br>toLowerCase()：将字符串转成小写字母。<br>toUpperCase()：将字符串转成大写字符。<br>substring()：截取字符串。<br>equals()：字符串比较。</p>
<h2 id="34-抽象类必须要有抽象方法吗？"><a href="#34-抽象类必须要有抽象方法吗？" class="headerlink" title="34.抽象类必须要有抽象方法吗？"></a>34.抽象类必须要有抽象方法吗？</h2><p>不需要，抽象类不一定非要有抽象方法。<br>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">noAbstractMethod</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            sayHi();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHi</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hi~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">//  结果:hi~</span></span><br></pre></td></tr></table></figure>

<h2 id="35-java-中-IO-流分为几种？"><a href="#35-java-中-IO-流分为几种？" class="headerlink" title="35.java 中 IO 流分为几种？"></a>35.java 中 IO 流分为几种？</h2><p>按功能来分：输入流（input）、输出流（output）。</p>
<p>按类型来分：字节流和字符流。</p>
<p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。<br>36.Files的常用方法都有哪些？<br>Files.exists()：检测文件路径是否存在。<br>Files.createFile()：创建文件。<br>Files.createDirectory()：创建文件夹。<br>Files.delete()：删除一个文件或目录。<br>Files.copy()：复制文件。<br>Files.move()：移动文件。<br>Files.size()：查看文件个数。<br>Files.read()：读取文件。<br>Files.write()：写入文件。</p>
<h2 id="37-List、Set、Map-之间的区别是什么？"><a href="#37-List、Set、Map-之间的区别是什么？" class="headerlink" title="37.List、Set、Map 之间的区别是什么？"></a>37.List、Set、Map 之间的区别是什么？</h2><p><img src="https://img-blog.csdnimg.cn/20200120190952269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQ5NTM5MA==,size_16,color_FFFFFF,t_70" alt="å¨è¿éæå¥å¾çæè¿°"></p>
<h2 id="38-如何实现数组和-List-之间的转换？"><a href="#38-如何实现数组和-List-之间的转换？" class="headerlink" title="38.如何实现数组和 List 之间的转换？"></a>38.如何实现数组和 List 之间的转换？</h2><p>List转换成为数组：调用ArrayList的toArray方法。<br>数组转换成为List：调用Arrays的asList方法。</p>
<h2 id="39-ArrayList-和-Vector-的区别是什么？"><a href="#39-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="39.ArrayList 和 Vector 的区别是什么？"></a>39.ArrayList 和 Vector 的区别是什么？</h2><p>Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。<br>ArrayList比Vector快，它是异步，不会过载。<br>ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</p>
<h2 id="40-Array-和-ArrayList-有何区别？"><a href="#40-Array-和-ArrayList-有何区别？" class="headerlink" title="40.Array 和 ArrayList 有何区别？"></a>40.Array 和 ArrayList 有何区别？</h2><p>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。<br>Array是指定大小的，而ArrayList初始大小是固定的。<br>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。<br>41.在 Queue 中 poll()和 remove()有什么区别？<br>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p>
<h2 id="42-哪些集合类是线程安全的？"><a href="#42-哪些集合类是线程安全的？" class="headerlink" title="42.哪些集合类是线程安全的？"></a>42.哪些集合类是线程安全的？</h2><p>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。<br>statck：堆栈类，先进后出。<br>hashtable：就比hashmap多了个线程安全。<br>enumeration：枚举，相当于迭代器。</p>
<h2 id="43-迭代器-Iterator-是什么？"><a href="#43-迭代器-Iterator-是什么？" class="headerlink" title="43.迭代器 Iterator 是什么？"></a>43.迭代器 Iterator 是什么？</h2><p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。</p>
<h2 id="44-Iterator-怎么使用？有什么特点？"><a href="#44-Iterator-怎么使用？有什么特点？" class="headerlink" title="44.Iterator 怎么使用？有什么特点？"></a>44.Iterator 怎么使用？有什么特点？</h2><p>Java中的Iterator功能比较简单，并且只能单向移动：</p>
<p>(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,公共基类Collection提供iterator()方法。</p>
<p>(2) 使用next()获得序列中的下一个元素。</p>
<p>(3) 使用hasNext()检查序列中是否还有元素。</p>
<p>(4) 使用remove()将迭代器新返回的元素删除。</p>
<p>Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。</p>
<h2 id="45-Iterator-和-ListIterator-有什么区别？"><a href="#45-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="45.Iterator 和 ListIterator 有什么区别？"></a>45.Iterator 和 ListIterator 有什么区别？</h2><p>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List,见名知意,Set并不能使用ListIterator<br>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。<br>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p>
<h2 id="46-synchronized-和-volatile-的区别是什么？"><a href="#46-synchronized-和-volatile-的区别是什么？" class="headerlink" title="46.synchronized 和 volatile 的区别是什么？"></a>46.synchronized 和 volatile 的区别是什么？</h2><p>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。<br>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。<br>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。<br>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。<br>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</p>
<h2 id="47-给定一个文本-获取某字符串出现的次数"><a href="#47-给定一个文本-获取某字符串出现的次数" class="headerlink" title="47.给定一个文本,获取某字符串出现的次数"></a>47.给定一个文本,获取某字符串出现的次数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\Administrator\\Desktop\\行政区划配置表.txt&quot;</span>);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    a = is.read(b);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">String[] str = <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, a).split(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">    <span class="comment">//设置查询统计的字符串为a</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;a&quot;</span>.equals(str[i]))&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(count);&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="2-JVM-知识"><a href="#2-JVM-知识" class="headerlink" title="2.JVM 知识"></a>2.JVM 知识</h1><h2 id="1-什么情况下会发生栈内存溢出。"><a href="#1-什么情况下会发生栈内存溢出。" class="headerlink" title="1.什么情况下会发生栈内存溢出。"></a>1.什么情况下会发生栈内存溢出。</h2><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。<br>参考链接</p>
<h2 id="2-JVM-的内存结构，Eden-和-Survivor-比例。"><a href="#2-JVM-的内存结构，Eden-和-Survivor-比例。" class="headerlink" title="2.JVM 的内存结构，Eden 和 Survivor 比例。"></a>2.JVM 的内存结构，Eden 和 Survivor 比例。</h2><p>eden 和 survior 是按8比1分配的<br>参考链接<br>3.jvm 中一次完整的 GC 流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的jvm 参数。<br>对象诞生即新生代-&gt;eden，在进行minor gc过程中，如果依旧存活，移动到from，变成Survivor，进行标记代数，如此检查一定次数后，晋升为老年代，<br>参考链接1<br>参考链接2<br>参考链接3</p>
<h2 id="4-你知道哪几种垃圾收集器，各自的优缺点，重点讲下-cms，包括原理，流程，优缺点"><a href="#4-你知道哪几种垃圾收集器，各自的优缺点，重点讲下-cms，包括原理，流程，优缺点" class="headerlink" title="4.你知道哪几种垃圾收集器，各自的优缺点，重点讲下 cms，包括原理，流程，优缺点"></a>4.你知道哪几种垃圾收集器，各自的优缺点，重点讲下 cms，包括原理，流程，优缺点</h2><p>Serial、parNew、ParallelScavenge、SerialOld、ParallelOld、CMS、G1<br>参考链接</p>
<h2 id="5-垃圾回收算法的实现原理。"><a href="#5-垃圾回收算法的实现原理。" class="headerlink" title="5.垃圾回收算法的实现原理。"></a>5.垃圾回收算法的实现原理。</h2><p>参考链接</p>
<h2 id="6-当出现了内存溢出，你怎么排错。"><a href="#6-当出现了内存溢出，你怎么排错。" class="headerlink" title="6.当出现了内存溢出，你怎么排错。"></a>6.当出现了内存溢出，你怎么排错。</h2><p>首先分析是什么类型的内存溢出，对应的调整参数或者优化代码。<br>参考链接</p>
<h2 id="7-JVM-内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。"><a href="#7-JVM-内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。" class="headerlink" title="7.JVM 内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。"></a>7.JVM 内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。</h2><p>内存屏障：为了保障执行顺序和可见性的一条cpu指令<br>重排序：为了提高性能，编译器和处理器会对执行进行重拍<br>happen-before：操作间执行的顺序关系。有些操作先发生。<br>主内存：共享变量存储的区域即是主内存<br>工作内存：每个线程copy的本地内存，存储了该线程以读&#x2F;写共享变量的副本<br>参考链接1<br>参考链接2<br>参考链接3</p>
<h2 id="8-简单说说你了解的类加载器。"><a href="#8-简单说说你了解的类加载器。" class="headerlink" title="8.简单说说你了解的类加载器。"></a>8.简单说说你了解的类加载器。</h2><p>类加载器的分类（bootstrap,ext,app,curstom），类加载的流程(load-link-init)<br>参考链接</p>
<h2 id="9-讲讲-JAVA-的反射机制。"><a href="#9-讲讲-JAVA-的反射机制。" class="headerlink" title="9.讲讲 JAVA 的反射机制。"></a>9.讲讲 JAVA 的反射机制。</h2><p>Java程序在运行状态可以动态的获取类的所有属性和方法，并实例化该类，调用方法的功能<br>参考链接</p>
<h2 id="10-你们线上应用的-JVM-参数有哪些。"><a href="#10-你们线上应用的-JVM-参数有哪些。" class="headerlink" title="10.你们线上应用的 JVM 参数有哪些。"></a>10.你们线上应用的 JVM 参数有哪些。</h2><p>-server<br>-Xms6000M<br>-Xmx6000M<br>-Xmn500M<br>-XX:PermSize&#x3D;500M<br>-XX:MaxPermSize&#x3D;500M<br>-XX:SurvivorRatio&#x3D;65536<br>-XX:MaxTenuringThreshold&#x3D;0<br>-Xnoclassgc<br>-XX:+DisableExplicitGC<br>-XX:+UseParNewGC<br>-XX:+UseConcMarkSweepGC<br>-XX:+UseCMSCompactAtFullCollection<br>-XX:CMSFullGCsBeforeCompaction&#x3D;0<br>-XX:+CMSClassUnloadingEnabled<br>-XX:-CMSParallelRemarkEnabled<br>-XX:CMSInitiatingOccupancyFraction&#x3D;90<br>-XX:SoftRefLRUPolicyMSPerMB&#x3D;0<br>-XX:+PrintClassHistogram<br>-XX:+PrintGCDetails<br>-XX:+PrintGCTimeStamps<br>-XX:+PrintHeapAtGC<br>-Xloggc:log&#x2F;gc.log</p>
<h2 id="11-g1-和-cms-区别-吞吐量优先和响应优先的垃圾收集器选择。"><a href="#11-g1-和-cms-区别-吞吐量优先和响应优先的垃圾收集器选择。" class="headerlink" title="11.g1 和 cms 区别,吞吐量优先和响应优先的垃圾收集器选择。"></a>11.g1 和 cms 区别,吞吐量优先和响应优先的垃圾收集器选择。</h2><p>Cms是以获取最短回收停顿时间为目标的收集器。基于标记-清除算法实现。比较占用cpu资源，切易造成碎片。<br>G1是面向服务端的垃圾收集器，是jdk9默认的收集器，基于标记-整理算法实现。可利用多核、多cpu，保留分代，实现可预测停顿，可控。<br>参考链接<br>请解释如下 jvm 参数的含义：<br>-server -Xms512m -Xmx512m -Xss1024K<br>-XX:PermSize&#x3D;256m -XX:MaxPermSize&#x3D;512m -XX:MaxTenuringThreshold&#x3D;20<br>XX:CMSInitiatingOccupancyFraction&#x3D;80 -XX:+UseCMSInitiatingOccupancyOnly。<br>Server模式启动<br>最小堆内存512m<br>最大512m<br>每个线程栈空间1m<br>永久代256m<br>最大永久代512m<br>最大转为老年代检查次数20<br>Cms回收开启时机：内存占用80%<br>命令JVM不基于运行时收集的数据来启动CMS垃圾收集周期<br>12.32位系统jvm堆内存如下哪一个设置是最大且有效的( B )<br>A. -Xmx1000m<br>B. -Xmx1500m<br>C. -Xmx8G<br>D. 无限<br>JVM最大内存: 首先JVM内存限制于实际的最大物理内存，假设物理内存无限大的话，JVM内存的最大值跟操作系统有很大的关系。简单的说就32位处理器虽然可控内存空间有4GB,但是具体的操作系统会给一个限制，这个限制一般是2GB-3GB（一般来说Windows系统下为1.5G-2G，Linux系统下为2G-3G），而64bit以上的处理器就不会有限制了。</p>
<h1 id="3-开源框架知识"><a href="#3-开源框架知识" class="headerlink" title="3.开源框架知识"></a>3.开源框架知识</h1><h2 id="1-简单讲讲-tomcat-结构，以及其类加载器流程。"><a href="#1-简单讲讲-tomcat-结构，以及其类加载器流程。" class="headerlink" title="1.简单讲讲 tomcat 结构，以及其类加载器流程。"></a>1.简单讲讲 tomcat 结构，以及其类加载器流程。</h2><p>Server- –多个service<br>Container级别的：–&gt;engine–》host–&gt;context<br>Listenter<br>Connector<br>Logging、Naming、Session、JMX等等</p>
<p>通过WebappClassLoader 加载class<br>参考链接1<br>参考链接2<br>参考链接3<br>参考链接4</p>
<h2 id="2-tomcat-如何调优，涉及哪些参数。"><a href="#2-tomcat-如何调优，涉及哪些参数。" class="headerlink" title="2.tomcat 如何调优，涉及哪些参数。"></a>2.tomcat 如何调优，涉及哪些参数。</h2><p>硬件上选择，操作系统选择，版本选择，jdk选择，配置jvm参数，配置connector的线程数量，开启gzip压缩，trimSpaces，集群等<br>a) 内存优化：主要是对Tomcat启动参数进行优化，我们可以在Tomcat启动脚本中修改它的最大内存数等等。</p>
<p>b) 线程数优化：Tomcat的并发连接参数，主要在Tomcat配置文件中server.xml中配置，比如修改最小空闲连接线程数，用于提高系统处理性能等等。</p>
<p>c) 优化缓存：打开压缩功能，修改参数，比如压缩的输出内容大小默认为2KB，可以适当的修改。<br>参考链接</p>
<h2 id="3-讲讲-Spring-加载流程。"><a href="#3-讲讲-Spring-加载流程。" class="headerlink" title="3.讲讲 Spring 加载流程。"></a>3.讲讲 Spring 加载流程。</h2><p>通过listener入口，核心是在AbstractApplicationContext的refresh方法，在此处进行装载bean工厂，bean，创建bean实例，拦截器，后置处理器等。<br>参考链接</p>
<h2 id="4-讲讲-Spring-事务的传播属性。"><a href="#4-讲讲-Spring-事务的传播属性。" class="headerlink" title="4.讲讲 Spring 事务的传播属性。"></a>4.讲讲 Spring 事务的传播属性。</h2><p>七种传播属性。<br>事务传播行为<br>所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。在TransactionDefinition定义中包括了如下几个表示传播行为的常量：<br>①TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。<br>②TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。<br>③TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。<br>④TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。<br>⑤TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。<br>⑥TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。<br>⑦TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。<br>参考链接</p>
<h2 id="5-Spring-如何管理事务的。"><a href="#5-Spring-如何管理事务的。" class="headerlink" title="5.Spring 如何管理事务的。"></a>5.Spring 如何管理事务的。</h2><p>编程式和声明式<br>同上</p>
<h2 id="6-Spring-怎么配置事务（具体说出一些关键的-xml-元素）。"><a href="#6-Spring-怎么配置事务（具体说出一些关键的-xml-元素）。" class="headerlink" title="6.Spring 怎么配置事务（具体说出一些关键的 xml 元素）。"></a>6.Spring 怎么配置事务（具体说出一些关键的 xml 元素）。</h2><p>配置事务的方法有两种：<br>1）、基于XML的事务配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- from the file &#x27;context.xml&#x27; --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>  </span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>  </span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span>  </span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span>  </span></span><br><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;  </span></span></span><br><span class="line"><span class="string"><span class="tag">     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  </span></span></span><br><span class="line"><span class="string"><span class="tag">     http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd  </span></span></span><br><span class="line"><span class="string"><span class="tag">     http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&quot;</span>&gt;</span>  </span><br><span class="line">      </span><br><span class="line">  <span class="comment">&lt;!-- 数据元信息 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:oracle:thin:@rj-t42:1521:elvis&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 管理事务的类,指定我们用谁来管理我们的事务--&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 首先我们要把服务对象声明成一个bean  例如HelloService --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yintong.service.HelloService&quot;</span>/&gt;</span>  </span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 然后是声明一个事物建议tx:advice,spring为我们提供了事物的封装，这个就是封装在了&lt;tx:advice/&gt;中 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;tx:advice/&gt;有一个transaction-manager属性，我们可以用它来指定我们的事物由谁来管理。</span></span><br><span class="line"><span class="comment">      默认：事务传播设置是 REQUIRED，隔离级别是DEFAULT --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span>  </span><br><span class="line">      <span class="comment">&lt;!-- 配置这个事务建议的属性 --&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 指定所有get开头的方法执行在只读事务上下文中 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 其余方法执行在默认的读写上下文中 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line">  <span class="comment">&lt;!-- 我们定义一个切面，它匹配FooService接口定义的所有操作 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line">     <span class="comment">&lt;!-- &lt;aop:pointcut/&gt;元素定义AspectJ的切面表示法，这里是表示com.yintong.service.helloService包下的任意方法。 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;helloServiceOperation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.yintong.service.helloService.*(..))&quot;</span>/&gt;</span>  </span><br><span class="line">     <span class="comment">&lt;!-- 然后我们用一个通知器：&lt;aop:advisor/&gt;把这个切面和tx:advice绑定在一起，表示当这个切面：fooServiceOperation执行时tx:advice定义的通知逻辑将被执行 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;helloServiceOperation&quot;</span>/&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p>2）、基于注解方式的事务配置。<br>@Transactional：直接在Java源代码中声明事务的做法让事务声明和将受其影响的代码距离更近了，而且一般来说不会有不恰当的耦合的风险，因为，使用事务性的代码几乎总是被部署在事务环境中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>  </span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>  </span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span>  </span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span>  </span></span><br><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;  </span></span></span><br><span class="line"><span class="string"><span class="tag">     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  </span></span></span><br><span class="line"><span class="string"><span class="tag">     http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd  </span></span></span><br><span class="line"><span class="string"><span class="tag">     http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&quot;</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yintong.service.HelloService&quot;</span>/&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置注解事务 --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>参考链接</p>
<h2 id="7-说说你对-Spring-的理解，非单例注入的原理？它的生命周期？循环注入的原理，-aop-的实现原理，说说-aop-中的几个术语，它们是怎么相互工作的。"><a href="#7-说说你对-Spring-的理解，非单例注入的原理？它的生命周期？循环注入的原理，-aop-的实现原理，说说-aop-中的几个术语，它们是怎么相互工作的。" class="headerlink" title="7.说说你对 Spring 的理解，非单例注入的原理？它的生命周期？循环注入的原理， aop 的实现原理，说说 aop 中的几个术语，它们是怎么相互工作的。"></a>7.说说你对 Spring 的理解，非单例注入的原理？它的生命周期？循环注入的原理， aop 的实现原理，说说 aop 中的几个术语，它们是怎么相互工作的。</h2><p>AOP与IOC的概念（即spring的核心）</p>
<p>a) IOC：Spring是开源框架，使用框架可以使我们减少工作量，提高工作效率并且它是分层结构，即相对应的层处理对应的业务逻辑，减少代码的耦合度。而spring的核心是IOC控制反转和AOP面向切面编程。IOC控制反转主要强调的是程序之间的关系是由容器控制的，容器控制对象，控制了对外部资源的获取。而反转即为，在传统的编程中都是由我们创建对象获取依赖对象，而在IOC中是容器帮我们创建对象并注入依赖对象，正是容器帮我们查找和注入对象，对象是被获取，所以叫反转。</p>
<p>b) AOP：面向切面编程，主要是管理系统层的业务，比如日志，权限，事物等。AOP是将封装好的对象剖开，找出其中对多个对象产生影响的公共行为，并将其封装为一个可重用的模块，这个模块被命名为切面（aspect），切面将那些与业务逻辑无关，却被业务模块共同调用的逻辑提取并封装起来，减少了系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p>
<p>核心组件：bean，context，core，单例注入是通过单例beanFactory进行创建，生命周期是在创建的时候通过接口实现开启，循环注入是通过后置处理器，aop其实就是通过反射进行动态代理，pointcut，advice等。<br>Aop相关：<br>参考链接</p>
<h2 id="8-Springmvc-中-DispatcherServlet-初始化过程。"><a href="#8-Springmvc-中-DispatcherServlet-初始化过程。" class="headerlink" title="8.Springmvc 中 DispatcherServlet 初始化过程。"></a>8.Springmvc 中 DispatcherServlet 初始化过程。</h2><p>入口是web.xml中配置的ds，ds继承了HttpServletBean，FrameworkServlet，通过其中的init方法进行初始化装载bean和实例，initServletBean是实际完成上下文工作和bean初始化的方法。<br>参考链接</p>
<h2 id="9-springMVC的执行流程"><a href="#9-springMVC的执行流程" class="headerlink" title="9.springMVC的执行流程"></a>9.springMVC的执行流程</h2><p>springMVC是由dispatchservlet为核心的分层控制框架。首先客户端发出一个请求web服务器解析请求url并去匹配dispatchservlet的映射url，如果匹配上就将这个请求放入到dispatchservlet，dispatchservlet根据mapping映射配置去寻找相对应的handel，然后把处理权交给找到的handel，handel封装了处理业务逻辑的代码，当handel处理完后会返回一个逻辑视图modelandview给dispatchservlet，此时的modelandview是一个逻辑视图不是一个正式视图，所以dispatchservlet会通过viewresource视图资源去解析modelandview，然后将解析后的参数放到view中返回到客户端并展现。</p>
<h2 id="10-事物的理解"><a href="#10-事物的理解" class="headerlink" title="10.事物的理解"></a>10.事物的理解</h2><p>a) 事物具有原子性，一致性，持久性，隔离性<br>b) 原子性：是指在一个事物中，要么全部执行成功，要么全部失败回滚。<br>c) 一致性：事物执行之前和执行之后都处于一致性状态<br>d) 持久性：事物多数据的操作是永久性<br>e) 隔离性：当一个事物正在对数据进行操作时，另一个事物不可以对数据进行操作，也就是多个并发事物之间相互隔离。</p>
<h1 id="4-操作系统"><a href="#4-操作系统" class="headerlink" title="4.操作系统"></a>4.操作系统</h1><h2 id="1-Linux-系统下你关注过哪些内核参数，说说你知道的。"><a href="#1-Linux-系统下你关注过哪些内核参数，说说你知道的。" class="headerlink" title="1.Linux 系统下你关注过哪些内核参数，说说你知道的。"></a>1.Linux 系统下你关注过哪些内核参数，说说你知道的。</h2><p>Tcp&#x2F;ip io cpu memory<br>net.ipv4.tcp_syncookies &#x3D; 1<br>#启用syncookies<br>net.ipv4.tcp_max_syn_backlog &#x3D; 8192<br>#SYN队列长度<br>net.ipv4.tcp_synack_retries&#x3D;2<br>#SYN ACK重试次数<br>net.ipv4.tcp_fin_timeout &#x3D; 30<br>#主动关闭方FIN-WAIT-2超时时间<br>net.ipv4.tcp_keepalive_time &#x3D; 1200<br>#TCP发送keepalive消息的频度<br>net.ipv4.tcp_tw_reuse &#x3D; 1<br>#开启TIME-WAIT重用<br>net.ipv4.tcp_tw_recycle &#x3D; 1<br>#开启TIME-WAIT快速回收<br>net.ipv4.ip_local_port_range &#x3D; 1024 65000<br>#向外连接的端口范围<br>net.ipv4.tcp_max_tw_buckets &#x3D; 5000<br>#最大TIME-WAIT数量，超过立即清除<br>net.ipv4.tcp_syn_retries &#x3D; 2<br>#SYN重试次数<br>echo “fs.file-max&#x3D;65535” &gt;&gt; &#x2F;etc&#x2F;sysctl.conf<br>sysctl -p<br>参考链接</p>
<h2 id="2-Linux-下-IO-模型有几种，各自的含义是什么。"><a href="#2-Linux-下-IO-模型有几种，各自的含义是什么。" class="headerlink" title="2.Linux 下 IO 模型有几种，各自的含义是什么。"></a>2.Linux 下 IO 模型有几种，各自的含义是什么。</h2><p>阻塞式io，非阻塞io，io复用模型，信号驱动io模型，异步io模型。<br>参考链接1<br>参考链接2</p>
<h2 id="3-epoll-和-poll-有什么区别。"><a href="#3-epoll-和-poll-有什么区别。" class="headerlink" title="3.epoll 和 poll 有什么区别。"></a>3.epoll 和 poll 有什么区别。</h2><p>select的本质是采用32个整数的32位，即32* 32&#x3D; 1024来标识，fd值为1-1024。当fd的值超过1024限制时，就必须修改FD_SETSIZE的大小。这个时候就可以标识32* max值范围的fd。<br>对于单进程多线程，每个线程处理多个fd的情况，select是不适合的。<br>1.所有的线程均是从1-32*max进行扫描，每个线程处理的均是一段fd值，这样做有点浪费<br>2.1024上限问题，一个处理多个用户的进程，fd值远远大1024<br>所以这个时候应该采用poll，<br>poll传递的是数组头指针和该数组的长度，只要数组的长度不是很长，性能还是很不错的，因为poll一次在内核中申请4K（一个页的大小来存放fd），尽量控制在4K以内,<br>epoll还是poll的一种优化，返回后不需要对所有的fd进行遍历，在内核中维持了fd的列表。select和poll是将这个内核列表维持在用户态，然后传递到内核中。但是只有在2.6的内核才支持。<br>epoll更适合于处理大量的fd ，且活跃fd不是很多的情况，毕竟fd较多还是一个串行的操作<br>参考链接</p>
<h2 id="4-平时用到哪些-Linux-命令。"><a href="#4-平时用到哪些-Linux-命令。" class="headerlink" title="4.平时用到哪些 Linux 命令。"></a>4.平时用到哪些 Linux 命令。</h2><p>Ls,find,tar,tail,cp,rm,vi，grep,ps,pkill等等<br>参考链接</p>
<h2 id="5-用一行命令查看文件的最后五行。"><a href="#5-用一行命令查看文件的最后五行。" class="headerlink" title="5.用一行命令查看文件的最后五行。"></a>5.用一行命令查看文件的最后五行。</h2><p>Tail -n 5 filename</p>
<h2 id="6-用一行命令输出正在运行的-java-进程。"><a href="#6-用一行命令输出正在运行的-java-进程。" class="headerlink" title="6.用一行命令输出正在运行的 java 进程。"></a>6.用一行命令输出正在运行的 java 进程。</h2><p>ps -ef|grep Java</p>
<h2 id="7-介绍下你理解的操作系统中线程切换过程。"><a href="#7-介绍下你理解的操作系统中线程切换过程。" class="headerlink" title="7.介绍下你理解的操作系统中线程切换过程。"></a>7.介绍下你理解的操作系统中线程切换过程。</h2><p>控制权的转换，根据优先级切换上下文（用户，寄存器，系统）<br>参考链接</p>
<h2 id="8-进程和线程的区别。"><a href="#8-进程和线程的区别。" class="headerlink" title="8.进程和线程的区别。"></a>8.进程和线程的区别。</h2><p>Linux 实现并没有区分这两个概念（进程和线程）<br>进程：程序的一次执行<br>线程：CPU的基本调度单位<br>一个进程可以包含多个线程。<br>参考链接</p>
<h1 id="5-多线程"><a href="#5-多线程" class="headerlink" title="5.多线程"></a>5.多线程</h1><h2 id="1-多线程的几种实现方式，什么是线程安全。"><a href="#1-多线程的几种实现方式，什么是线程安全。" class="headerlink" title="1.多线程的几种实现方式，什么是线程安全。"></a>1.多线程的几种实现方式，什么是线程安全。</h2><p>实现runable接口，继承thread类。<br>参考链接</p>
<h2 id="2-volatile-的原理，作用，能代替锁么。"><a href="#2-volatile-的原理，作用，能代替锁么。" class="headerlink" title="2.volatile 的原理，作用，能代替锁么。"></a>2.volatile 的原理，作用，能代替锁么。</h2><p>Volatile利用内存栅栏机制来保持变量的一致性。不能代替锁，其只具备数据可见性一致性，不具备原子性。<br>参考链接</p>
<h2 id="3-画一个线程的生命周期状态图。"><a href="#3-画一个线程的生命周期状态图。" class="headerlink" title="3.画一个线程的生命周期状态图。"></a>3.画一个线程的生命周期状态图。</h2><p>新建，可运行，运行中，睡眠，阻塞，等待，死亡。</p>
<p><img src="https://img-blog.csdn.net/20170825175714106?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDA0MjA2Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="è¿éåå¾çæè¿°"></p>
<p>参考链接</p>
<h2 id="4-sleep-和-wait-的区别。"><a href="#4-sleep-和-wait-的区别。" class="headerlink" title="4.sleep 和 wait 的区别。"></a>4.sleep 和 wait 的区别。</h2><p>Sleep是休眠线程，wait是等待，sleep是thread的静态方法，wait则是object的方法。<br>Sleep依旧持有锁，并在指定时间自动唤醒。wait则释放锁。<br>参考链接</p>
<h2 id="5-Lock-与-Synchronized-的区别。"><a href="#5-Lock-与-Synchronized-的区别。" class="headerlink" title="5.Lock 与 Synchronized 的区别。"></a>5.Lock 与 Synchronized 的区别。</h2><p>首先两者都保持了并发场景下的原子性和可见性，区别则是synchronized的释放锁机制是交由其自身控制，且互斥性在某些场景下不符合逻辑，无法进行干预，不可人为中断等。<br>而lock常用的则有ReentrantLock和readwritelock两者，添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。<br>参考链接</p>
<h2 id="6-synchronized-的原理是什么，解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。"><a href="#6-synchronized-的原理是什么，解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。" class="headerlink" title="6.synchronized 的原理是什么，解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。"></a>6.synchronized 的原理是什么，解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。</h2><p>Synchronized底层是通过监视器的enter和exit实现<br>参考链接1<br>参考链接2</p>
<h2 id="7-用过哪些原子类，他们的原理是什么。"><a href="#7-用过哪些原子类，他们的原理是什么。" class="headerlink" title="7.用过哪些原子类，他们的原理是什么。"></a>7.用过哪些原子类，他们的原理是什么。</h2><p>AtomicInteger； AtomicLong； AtomicReference； AtomicBoolean；基于CAS原语实现 ，比较并交换、加载链接&#x2F;条件存储，最坏的情况下是旋转锁<br>参考链接1<br>参考链接2</p>
<h2 id="8-用过线程池吗，newCache-和-newFixed-有什么区别，他们的原理简单概括下，构造函数的各个参数的含义是什么，比如-coreSize，maxsize-等。"><a href="#8-用过线程池吗，newCache-和-newFixed-有什么区别，他们的原理简单概括下，构造函数的各个参数的含义是什么，比如-coreSize，maxsize-等。" class="headerlink" title="8.用过线程池吗，newCache 和 newFixed 有什么区别，他们的原理简单概括下，构造函数的各个参数的含义是什么，比如 coreSize，maxsize 等。"></a>8.用过线程池吗，newCache 和 newFixed 有什么区别，他们的原理简单概括下，构造函数的各个参数的含义是什么，比如 coreSize，maxsize 等。</h2><p>newSingleThreadExecutor返回以个包含单线程的Executor,将多个任务交给此Exector时，这个线程处理完一个任务后接着处理下一个任务，若该线程出现异常，将会有一个新的线程来替代。<br>newFixedThreadPool返回一个包含指定数目线程的线程池，如果任务数量多于线程数目，那么没有没有执行的任务必须等待，直到有任务完成为止。<br>newCachedThreadPool根据用户的任务数创建相应的线程来处理，该线程池不会对线程数目加以限制，完全依赖于JVM能创建线程的数量，可能引起内存不足。<br>底层是基于ThreadPoolExecutor实现，借助reentrantlock保证并发。<br>coreSize核心线程数，maxsize最大线程数。<br>参考链接</p>
<h2 id="9-线程池的关闭方式有几种，各自的区别是什么。"><a href="#9-线程池的关闭方式有几种，各自的区别是什么。" class="headerlink" title="9.线程池的关闭方式有几种，各自的区别是什么。"></a>9.线程池的关闭方式有几种，各自的区别是什么。</h2><p>Shutdown shutdownNow tryTerminate 清空工作队列，终止线程池中各个线程，销毁线程池<br>参考链接</p>
<h2 id="10-假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有-10-个线程同时调用它，如何做到。"><a href="#10-假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有-10-个线程同时调用它，如何做到。" class="headerlink" title="10.假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有 10 个线程同时调用它，如何做到。"></a>10.假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有 10 个线程同时调用它，如何做到。</h2><p>ScheduledThreadPoolExecutor 设置定时，进行调度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, TimeUnit.NANOSECONDS,</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>(), threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>参考链接</p>
<h2 id="11-spring-的-controller-是单例还是多例，怎么保证并发的安全。"><a href="#11-spring-的-controller-是单例还是多例，怎么保证并发的安全。" class="headerlink" title="11.spring 的 controller 是单例还是多例，怎么保证并发的安全。"></a>11.spring 的 controller 是单例还是多例，怎么保证并发的安全。</h2><p>单例<br>通过单例工厂 DefaultSingletonBeanRegistry实现单例<br>通过AsyncTaskExecutor保持安全</p>
<h2 id="12-用三个线程按顺序循环打印-abc-三个字母，比如-abcabcabc。"><a href="#12-用三个线程按顺序循环打印-abc-三个字母，比如-abcabcabc。" class="headerlink" title="12.用三个线程按顺序循环打印 abc 三个字母，比如 abcabcabc。"></a>12.用三个线程按顺序循环打印 abc 三个字母，比如 abcabcabc。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ABC_Synch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadPrinter</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Object prev;</span><br><span class="line">        <span class="keyword">private</span> Object self;</span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">ThreadPrinter</span><span class="params">(String name, Object prev, Object self)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">            <span class="built_in">this</span>.self = self;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;<span class="comment">// 多线程并发，不能用if，必须使用whil循环</span></span><br><span class="line">                <span class="keyword">synchronized</span> (prev) &#123; <span class="comment">// 先获取 prev 锁</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (self) &#123;<span class="comment">// 再获取 self 锁</span></span><br><span class="line">                        System.out.print(name);<span class="comment">//打印</span></span><br><span class="line">                        count--;</span><br><span class="line">             self.notifyAll();<span class="comment">// 唤醒其他线程竞争self锁，注意此时self锁并未立即释放。</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//此时执行完self的同步块，这时self锁才释放。</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    prev.wait(); <span class="comment">// 立即释放 prev锁，当前线程休眠，等待唤醒</span></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">ThreadPrinter</span> <span class="variable">pa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPrinter</span>(<span class="string">&quot;A&quot;</span>, c, a);</span><br><span class="line">    <span class="type">ThreadPrinter</span> <span class="variable">pb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPrinter</span>(<span class="string">&quot;B&quot;</span>, a, b);</span><br><span class="line">    <span class="type">ThreadPrinter</span> <span class="variable">pc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPrinter</span>(<span class="string">&quot;C&quot;</span>, b, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(pa).start();</span><br><span class="line">    Thread.sleep(<span class="number">10</span>);<span class="comment">//保证初始ABC的启动顺序</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(pb).start();</span><br><span class="line">    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(pc).start();</span><br><span class="line">    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考链接</p>
<h2 id="13-ThreadLocal-用过么，用途是什么，原理是什么，用的时候要注意什么。"><a href="#13-ThreadLocal-用过么，用途是什么，原理是什么，用的时候要注意什么。" class="headerlink" title="13.ThreadLocal 用过么，用途是什么，原理是什么，用的时候要注意什么。"></a>13.ThreadLocal 用过么，用途是什么，原理是什么，用的时候要注意什么。</h2><p>Threadlocal底层是通过threadlocalMap进行存储键值 每个ThreadLocal类创建一个Map，然后用线程的ID作为Map的key，实例对象作为Map的value，这样就能达到各个线程的值隔离的效果。<br>ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。<br>谁设置谁负责移除<br>参考链接1<br>参考链接2</p>
<h2 id="14-如果让你实现一个并发安全的链表，你会怎么做。"><a href="#14-如果让你实现一个并发安全的链表，你会怎么做。" class="headerlink" title="14.如果让你实现一个并发安全的链表，你会怎么做。"></a>14.如果让你实现一个并发安全的链表，你会怎么做。</h2><p>Collections.synchronizedList() ConcurrentLinkedQueue<br>参考链接</p>
<h2 id="15-有哪些无锁数据结构，他们实现的原理是什么。"><a href="#15-有哪些无锁数据结构，他们实现的原理是什么。" class="headerlink" title="15.有哪些无锁数据结构，他们实现的原理是什么。"></a>15.有哪些无锁数据结构，他们实现的原理是什么。</h2><p>LockFree，CAS<br>基于jdk提供的原子类原语实现，例如AtomicReference<br>参考链接</p>
<h2 id="16-讲讲-java-同步机制的-wait-和-notify。"><a href="#16-讲讲-java-同步机制的-wait-和-notify。" class="headerlink" title="16.讲讲 java 同步机制的 wait 和 notify。"></a>16.讲讲 java 同步机制的 wait 和 notify。</h2><p>首先这两个方法只能在同步代码块中调用，wait会释放掉对象锁，等待notify唤醒。<br>参考链接</p>
<h2 id="17-多线程如果线程挂住了怎么办。"><a href="#17-多线程如果线程挂住了怎么办。" class="headerlink" title="17.多线程如果线程挂住了怎么办。"></a>17.多线程如果线程挂住了怎么办。</h2><p>根据具体情况（sleep,wait,join等），酌情选择notifyAll，notify进行线程唤醒。<br>参考链接</p>
<h2 id="18-countdowlatch-和-cyclicbarrier-的内部原理和用法，以及相互之间的差别。"><a href="#18-countdowlatch-和-cyclicbarrier-的内部原理和用法，以及相互之间的差别。" class="headerlink" title="18.countdowlatch 和 cyclicbarrier 的内部原理和用法，以及相互之间的差别。"></a>18.countdowlatch 和 cyclicbarrier 的内部原理和用法，以及相互之间的差别。</h2><p>CountDownLatch是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它运行一个或者多个线程一直处于等待状态。<br>CyclicBarrier要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。<br>CyclicBarrier初始化的时候，设置一个屏障数。线程调用await()方法的时候，这个线程就会被阻塞，当调用await()的线程数量到达屏障数的时候，主线程就会取消所有被阻塞线程的状态。<br>前者是递减，不可循环，后者是递加，可循环用<br>countdowlatch 基于abq cb基于ReentrantLock Condition<br>参考链接1<br>参考链接2</p>
<h2 id="19-使用-synchronized-修饰静态方法和非静态方法有什么区别。"><a href="#19-使用-synchronized-修饰静态方法和非静态方法有什么区别。" class="headerlink" title="19.使用 synchronized 修饰静态方法和非静态方法有什么区别。"></a>19.使用 synchronized 修饰静态方法和非静态方法有什么区别。</h2><p>对象锁和类锁<br>参考链接</p>
<h2 id="20-简述-ConcurrentLinkedQueue-LinkedBlockingQueue-的用处和不同之处。"><a href="#20-简述-ConcurrentLinkedQueue-LinkedBlockingQueue-的用处和不同之处。" class="headerlink" title="20.简述 ConcurrentLinkedQueue LinkedBlockingQueue 的用处和不同之处。"></a>20.简述 ConcurrentLinkedQueue LinkedBlockingQueue 的用处和不同之处。</h2><p>LinkedBlockingQueue 是一个基于单向链表的、范围任意的（其实是有界的）、FIFO 阻塞队列。<br>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现，该算法在Michael &amp; Scott算法上进行了一些修改, Michael &amp; Scott算法的详细信息可以参见参考资料一。<br>参考链接1<br>参考链接2<br>参考链接3<br>##导致线程死锁的原因？怎么解除线程死锁。<br>死锁问题是多线程特有的问题，它可以被认为是线程间切换消耗系统性能的一种极端情况。在死锁时，线程间相互等待资源，而又不释放自身的资源，导致无穷无尽的等待，其结果是系统任务永远无法执行完成。死锁问题是在多线程开发中应该坚决避免和杜绝的问题。<br>一般来说，要出现死锁问题需要满足以下条件：</p>
<p>1.互斥条件：一个资源每次只能被一个线程使用。<br>2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>3.不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。<br>4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。<br>5.只要破坏死锁 4 个必要条件之一中的任何一个，死锁问题就能被解决。</p>
<p>参考链接</p>
<h2 id="21-非常多个线程（可能是不同机器），相互之间需要等待协调，才能完成某种工作，问怎么设计这种协调方案。"><a href="#21-非常多个线程（可能是不同机器），相互之间需要等待协调，才能完成某种工作，问怎么设计这种协调方案。" class="headerlink" title="21.非常多个线程（可能是不同机器），相互之间需要等待协调，才能完成某种工作，问怎么设计这种协调方案。"></a>21.非常多个线程（可能是不同机器），相互之间需要等待协调，才能完成某种工作，问怎么设计这种协调方案。</h2><p>此问题的本质是保持顺序执行。可以使用executors<br>#TCP 与 HTTP</p>
<h2 id="22-http1-0-和-http1-1-有什么区别。"><a href="#22-http1-0-和-http1-1-有什么区别。" class="headerlink" title="22.http1.0 和 http1.1 有什么区别。"></a>22.http1.0 和 http1.1 有什么区别。</h2><p>HTTP 1.0主要有以下几点变化：<br>请求和相应可以由于多行首部字段构成<br>响应对象前面添加了一个响应状态行<br>响应对象不局限于超文本<br>服务器与客户端之间的连接在每次请求之后都会关闭<br>实现了Expires等传输内容的缓存控制<br>内容编码Accept-Encoding、字符集Accept-Charset等协商内容的支持<br>这时候开始有了请求及返回首部的概念，开始传输不限于文本（其他二进制内容）<br>HTTP 1.1加入了很多重要的性能优化：持久连接、分块编码传输、字节范围请求、增强的缓存机制、传输编码及请求管道。<br>参考链接</p>
<h2 id="23-TCP-三次握手和四次挥手的流程，为什么断开连接要-4-次-如果握手只有两次，会出现什么。"><a href="#23-TCP-三次握手和四次挥手的流程，为什么断开连接要-4-次-如果握手只有两次，会出现什么。" class="headerlink" title="23.TCP 三次握手和四次挥手的流程，为什么断开连接要 4 次,如果握手只有两次，会出现什么。"></a>23.TCP 三次握手和四次挥手的流程，为什么断开连接要 4 次,如果握手只有两次，会出现什么。</h2><p>第一次握手(SYN&#x3D;1, seq&#x3D;x):<br>客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。<br>发送完毕后，客户端进入 <code>SYN_SEND</code> 状态。</p>
<p>第二次握手(SYN&#x3D;1, ACK&#x3D;1, seq&#x3D;y, ACKnum&#x3D;x+1):<br>服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。<br>发送完毕后，服务器端进入 <code>SYN_RCVD</code> 状态。</p>
<p>第三次握手(ACK&#x3D;1，ACKnum&#x3D;y+1)<br>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1</p>
<p>发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。<br>第一次挥手(FIN&#x3D;1，seq&#x3D;x)<br>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。<br>发送完毕后，客户端进入 FIN_WAIT_1 状态。<br>第二次挥手(ACK&#x3D;1，ACKnum&#x3D;x+1)<br>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。<br>发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。<br>第三次挥手(FIN&#x3D;1，seq&#x3D;y)<br>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。<br>发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。<br>第四次挥手(ACK&#x3D;1，ACKnum&#x3D;y+1)<br>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。<br>服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。<br>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。<br>两次后会重传直到超时。如果多了会有大量半链接阻塞队列。<br>参考链接1<br>参考链接2</p>
<h2 id="24-TIME-WAIT-和-CLOSE-WAIT-的区别。"><a href="#24-TIME-WAIT-和-CLOSE-WAIT-的区别。" class="headerlink" title="24.TIME_WAIT 和 CLOSE_WAIT 的区别。"></a>24.TIME_WAIT 和 CLOSE_WAIT 的区别。</h2><p>TIME_WAIT状态就是用来重发可能丢失的ACK报文。<br>TIME_WAIT 表示主动关闭，CLOSE_WAIT 表示被动关闭。</p>
<h2 id="25-说说你知道的几种-HTTP-响应码，比如-200-302-404。"><a href="#25-说说你知道的几种-HTTP-响应码，比如-200-302-404。" class="headerlink" title="25.说说你知道的几种 HTTP 响应码，比如 200, 302, 404。"></a>25.说说你知道的几种 HTTP 响应码，比如 200, 302, 404。</h2><p>1xx：信息，请求收到，继续处理<br>2xx：成功，行为被成功地接受、理解和采纳<br>3xx：重定向，为了完成请求，必须进一步执行的动作<br>4xx：客户端错误，请求包含语法错误或者请求无法实现<br>5xx：服务器错误，服务器不能实现一种明显无效的请求<br>200 ok 一切正常<br>302 Moved Temporatily 文件临时移出<br>404 not found<br>参考链接</p>
<h2 id="26-当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤。"><a href="#26-当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤。" class="headerlink" title="26.当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤。"></a>26.当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤。</h2><p>Dns解析–&gt;端口分析–&gt;tcp请求–&gt;服务器处理请求–&gt;服务器响应–&gt;浏览器解析—&gt;链接关闭</p>
<h2 id="27-TCP-x2F-IP-如何保证可靠性，说说-TCP-头的结构。"><a href="#27-TCP-x2F-IP-如何保证可靠性，说说-TCP-头的结构。" class="headerlink" title="27.TCP&#x2F;IP 如何保证可靠性，说说 TCP 头的结构。"></a>27.TCP&#x2F;IP 如何保证可靠性，说说 TCP 头的结构。</h2><p>使用序号，对收到的TCP报文段进行排序以及检测重复的数据；使用校验和来检测报文段的错误；使用确认和计时器来检测和纠正丢包或延时。&#x2F;&#x2F;TCP头部，总长度20字节</p>
<p>typedef struct _tcp_hdr<br>    {<br>        unsigned short src_port;    &#x2F;&#x2F;源端口号<br>        unsigned short dst_port;    &#x2F;&#x2F;目的端口号<br>        unsigned int seq_no;        &#x2F;&#x2F;序列号<br>        unsigned int ack_no;        &#x2F;&#x2F;确认号<br>        #if LITTLE_ENDIAN<br>        unsigned char reserved_1:4; &#x2F;&#x2F;保留6位中的4位首部长度<br>        unsigned char thl:4;        &#x2F;&#x2F;tcp头部长度<br>        unsigned char flag:6;       &#x2F;&#x2F;6位标志<br>        unsigned char reseverd_2:2; &#x2F;&#x2F;保留6位中的2位<br>        #else<br>        unsigned char thl:4;        &#x2F;&#x2F;tcp头部长度<br>        unsigned char reserved_1:4; &#x2F;&#x2F;保留6位中的4位首部长度<br>        unsigned char reseverd_2:2; &#x2F;&#x2F;保留6位中的2位<br>        unsigned char flag:6;       &#x2F;&#x2F;6位标志<br>        #endif<br>        unsigned short wnd_size;    &#x2F;&#x2F;16位窗口大小<br>        unsigned short chk_sum;     &#x2F;&#x2F;16位TCP检验和<br>        unsigned short urgt_p;      &#x2F;&#x2F;16为紧急指针<br>    }<br>tcp_hdr;<br>参考链接</p>
<h2 id="28-如何避免浏览器缓存。"><a href="#28-如何避免浏览器缓存。" class="headerlink" title="28.如何避免浏览器缓存。"></a>28.如何避免浏览器缓存。</h2><p>无法被浏览器缓存的请求：<br>HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache，或Cache-Control:max-age&#x3D;0等告诉浏览器不用缓存的请求<br>需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的<br>经过HTTPS安全加密的请求（有人也经过测试发现，ie其实在头部加入Cache-Control：max-age信息，firefox在头部加入Cache-Control:Public之后，能够对HTTPS的资源进行缓存，参考《HTTPS的七个误解》）<br>POST请求无法被缓存<br>HTTP响应头中不包含Last-Modified&#x2F;Etag，也不包含Cache-Control&#x2F;Expires的请求无法被缓存<br>参考链接</p>
<h2 id="29-简述-Http-请求-get-和-post-的区别以及数据包格式。"><a href="#29-简述-Http-请求-get-和-post-的区别以及数据包格式。" class="headerlink" title="29.简述 Http 请求 get 和 post 的区别以及数据包格式。"></a>29.简述 Http 请求 get 和 post 的区别以及数据包格式。</h2><p>参考链接1<br>参考链接2</p>
<h2 id="30-简述-HTTP-请求的报文格式。"><a href="#30-简述-HTTP-请求的报文格式。" class="headerlink" title="30.简述 HTTP 请求的报文格式。"></a>30.简述 HTTP 请求的报文格式。</h2><p>参考上面</p>
<h2 id="31-HTTPS-的加密方式是什么，讲讲整个加密解密流程。"><a href="#31-HTTPS-的加密方式是什么，讲讲整个加密解密流程。" class="headerlink" title="31.HTTPS 的加密方式是什么，讲讲整个加密解密流程。"></a>31.HTTPS 的加密方式是什么，讲讲整个加密解密流程。</h2><p>加密方式是tls&#x2F;ssl，底层是通过对称算法，非对称，hash算法实现<br>客户端发起HTTPS请求 –》2. 服务端的配置 –》</p>
<ol start="3">
<li>传送证书 —》4. 客户端解析证书 5. 传送加密信息 6. 服务段解密信息 7. 传输加密后的信息 8. 客户端解密信息<br> 参考链接<br> #架构设计与分布式</li>
</ol>
<h2 id="32-常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的。"><a href="#32-常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的。" class="headerlink" title="32.常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的。"></a>32.常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的。</h2><p>  Cdn缓存，redis缓存，ehcache缓存等<br>  Cdn 图片资源 js等， redis一主一从 echcache缓存数据</p>
<h2 id="33-用-java-自己实现一个-LRU。"><a href="#33-用-java-自己实现一个-LRU。" class="headerlink" title="33.用 java 自己实现一个 LRU。"></a>33.用 java 自己实现一个 LRU。</h2>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">cacheSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">Map&amp;lt;String, String&amp;gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&amp;lt;String, String&amp;gt;((<span class="type">int</span>) Math.ceil(cacheSize / <span class="number">0.75f</span>) + <span class="number">1</span>, <span class="number">0.75f</span>, <span class="literal">true</span>) &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&amp;lt;String, String&amp;gt; eldest)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> size() &amp;gt; cacheSize;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参考链接</p>
<h2 id="34-分布式集群下如何做到唯一序列号。"><a href="#34-分布式集群下如何做到唯一序列号。" class="headerlink" title="34.分布式集群下如何做到唯一序列号。"></a>34.分布式集群下如何做到唯一序列号。</h2><p>Redis生成，mongodb的objectId，zk生成<br>参考链接</p>
<h2 id="35-设计一个秒杀系统，30-分钟没付款就自动关闭交易。"><a href="#35-设计一个秒杀系统，30-分钟没付款就自动关闭交易。" class="headerlink" title="35.设计一个秒杀系统，30 分钟没付款就自动关闭交易。"></a>35.设计一个秒杀系统，30 分钟没付款就自动关闭交易。</h2><p>分流 – 限流–异步–公平性（只能参加一次）–用户体验（第几位，多少分钟，一抢完）<br>容错处理<br>Redis 队列 mysql<br>30分钟关闭 可以借助redis的发布订阅机制 在失效时进行后续操作，其他mq也可以<br>参考链接</p>
<h2 id="36-如何使用-redis-和-zookeeper-实现分布式锁？有什么区别优缺点，分别适用什么场景。"><a href="#36-如何使用-redis-和-zookeeper-实现分布式锁？有什么区别优缺点，分别适用什么场景。" class="headerlink" title="36.如何使用 redis 和 zookeeper 实现分布式锁？有什么区别优缺点，分别适用什么场景。"></a>36.如何使用 redis 和 zookeeper 实现分布式锁？有什么区别优缺点，分别适用什么场景。</h2><p>首先分布式锁实现常见的有数据库锁(表记录)，缓存锁，基于zk（临时有序节点可以实现的）的三种<br>Redis适用于对性能要求特别高的场景。redis可以每秒执行10w次，内网延迟不超过1ms<br>缺点是数据存放于内存，宕机后锁丢失。<br>锁无法释放？使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。<br>非阻塞锁？使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。<br>不可重入？使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。<br>单点问题？使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。<br>参考链接</p>
<h2 id="37-如果有人恶意创建非法连接，怎么解决。"><a href="#37-如果有人恶意创建非法连接，怎么解决。" class="headerlink" title="37.如果有人恶意创建非法连接，怎么解决。"></a>37.如果有人恶意创建非法连接，怎么解决。</h2><p>可以使用filter过滤处理</p>
<h2 id="38-分布式事务的原理，优缺点，如何使用分布式事务。"><a href="#38-分布式事务的原理，优缺点，如何使用分布式事务。" class="headerlink" title="38.分布式事务的原理，优缺点，如何使用分布式事务。"></a>38.分布式事务的原理，优缺点，如何使用分布式事务。</h2><p>Two Phase commit协议<br>优点是可以管理多机事务，拥有无线扩展性 确定是易用性难，承担延时风险<br>JTA，atomiks等<br>参考链接</p>
<h2 id="39-什么是一致性-hash。"><a href="#39-什么是一致性-hash。" class="headerlink" title="39.什么是一致性 hash。"></a>39.什么是一致性 hash。</h2><p>一致性hash是一种分布式hash实现算法。满足平衡性 单调性 分散性 和负载。<br>参考链接</p>
<h2 id="40-什么是-restful，讲讲你理解的-restful。"><a href="#40-什么是-restful，讲讲你理解的-restful。" class="headerlink" title="40.什么是 restful，讲讲你理解的 restful。"></a>40.什么是 restful，讲讲你理解的 restful。</h2><p>REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。<br>参考链接</p>
<h2 id="41-如何设计建立和保持-100w-的长连接。"><a href="#41-如何设计建立和保持-100w-的长连接。" class="headerlink" title="41.如何设计建立和保持 100w 的长连接。"></a>41.如何设计建立和保持 100w 的长连接。</h2><p>服务器内核调优(tcp，文件数)，客户端调优，框架选择(netty)</p>
<h2 id="42-如何防止缓存雪崩。"><a href="#42-如何防止缓存雪崩。" class="headerlink" title="42.如何防止缓存雪崩。"></a>42.如何防止缓存雪崩。</h2><p>缓存雪崩可能是因为数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。<br>解决思路：<br>1，采用加锁计数，或者使用合理的队列数量来避免缓存失效时对数据库造成太大的压力。这种办法虽然能缓解数据库的压力，但是同时又降低了系统的吞吐量。<br>2，分析用户行为，尽量让失效时间点均匀分布。避免缓存雪崩的出现。<br>3，如果是因为某台缓存服务器宕机，可以考虑做主备，比如：redis主备，但是双缓存涉及到更新事务的问题，update可能读到脏数据，需要好好解决。<br>参考链接</p>
<h2 id="43-解释什么是-MESI-协议-缓存一致性-。"><a href="#43-解释什么是-MESI-协议-缓存一致性-。" class="headerlink" title="43.解释什么是 MESI 协议(缓存一致性)。"></a>43.解释什么是 MESI 协议(缓存一致性)。</h2><p>MESI是四种缓存段状态的首字母缩写，任何多核系统中的缓存段都处于这四种状态之一。我将以相反的顺序逐个讲解，因为这个顺序更合理：<br>失效（Invalid）缓存段，要么已经不在缓存中，要么它的内容已经过时。为了达到缓存的目的，这种状态的段将会被忽略。一旦缓存段被标记为失效，那效果就等同于它从来没被加载到缓存中。<br>共享（Shared）缓存段，它是和主内存内容保持一致的一份拷贝，在这种状态下的缓存段只能被读取，不能被写入。多组缓存可以同时拥有针对同一内存地址的共享缓存段，这就是名称的由来。<br>独占（Exclusive）缓存段，和S状态一样，也是和主内存内容保持一致的一份拷贝。区别在于，如果一个处理器持有了某个E状态的缓存段，那其他处理器就不能同时持有它，所以叫“独占”。这意味着，如果其他处理器原本也持有同一缓存段，那么它会马上变成“失效”状态。<br>已修改（Modified）缓存段，属于脏段，它们已经被所属的处理器修改了。如果一个段处于已修改状态，那么它在其他处理器缓存中的拷贝马上会变成失效状态，这个规律和E状态一样。此外，已修改缓存段如果被丢弃或标记为失效，那么先要把它的内容回写到内存中——这和回写模式下常规的脏段处理方式一样。</p>
<h2 id="44-说说你知道的几种-HASH-算法，简单的也可以。"><a href="#44-说说你知道的几种-HASH-算法，简单的也可以。" class="headerlink" title="44.说说你知道的几种 HASH 算法，简单的也可以。"></a>44.说说你知道的几种 HASH 算法，简单的也可以。</h2><p>哈希(Hash)算法,即散列函数。 它是一种单向密码体制,即它是一个从明文到密文的不可逆的映射,只有加密过程,没有解密过程。 同时,哈希函数可以将任意长度的输入经过变化以后得到固定长度的输出<br>MD4 MD5 SHA<br>参考链接</p>
<h2 id="45-什么是-paxos-算法。"><a href="#45-什么是-paxos-算法。" class="headerlink" title="45.什么是 paxos 算法。"></a>45.什么是 paxos 算法。</h2><p>Paxos算法是莱斯利·兰伯特（Leslie Lamport，就是 LaTeX 中的”La”，此人现在在微软研究院）于1990年提出的一种基于消息传递的一致性算法。<br>参考链接<br>##什么是 zab 协议。<br>ZAB 是 Zookeeper 原子广播协议的简称<br>整个ZAB协议主要包括消息广播和崩溃恢复两个过程，进一步可以分为三个阶段，分别是：<br>发现 Discovery<br>同步 Synchronization<br>广播 Broadcast<br>组成ZAB协议的每一个分布式进程，都会循环执行这三个阶段，将这样一个循环称为一个主进程周期。<br>参考链接<br>##一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新。<br>点击编辑的时候，利用redis进行加锁setNX完了之后 expire 一下<br>也可以用版本号进行控制</p>
<h2 id="46-线上系统突然变得异常缓慢，你如何查找问题。"><a href="#46-线上系统突然变得异常缓慢，你如何查找问题。" class="headerlink" title="46.线上系统突然变得异常缓慢，你如何查找问题。"></a>46.线上系统突然变得异常缓慢，你如何查找问题。</h2><p>逐级排查（网络，磁盘，内存，cpu），数据库，日志，中间件等也可通过监控工具排查。</p>
<h2 id="47-说说你平时用到的设计模式。"><a href="#47-说说你平时用到的设计模式。" class="headerlink" title="47.说说你平时用到的设计模式。"></a>47.说说你平时用到的设计模式。</h2><p>单例， 代理，模板，策略，命令<br>a) 单例模式：单例模式核心只需要new一个实例对象的模式，比如数据库连接，在线人数等，一些网站上看到的在线人数统计就是通过单例模式实现的，把一个计时器存放在数据库或者内存中，当有人登陆的时候取出来加一再放回去，有人退出登陆的时候取出来减一再放回去，但是当有两个人同时登陆的时候，会同时取出计数器，同时加一，同时放回去，这样的话数据就会错误，所以需要一个全局变量的对象给全部人使用，只需要new出一个实例对象，这就是单例模式的应用，并且单例模式节省资源，因为它控制了实例对象的个数，并有利于gc回收。</p>
<p>b) 策略模式：就是将几个类中公共的方法提取到一个新的类中，从而使扩展更容易，保证代码的可移植性，可维护性强。比如有个需求是写鸭子对象，鸭子有叫，飞，外形这三种方法，如果每个鸭子类都写这三个方法会出现代码的冗余，这时候我们可以把鸭子中的叫，飞，外形这三个方法提取出来，放到鸭父类中，让每个鸭子都继承这个鸭父类，重写这三个方法，这样封装的代码可移植性强，当用户提出新的需求比如鸭子会游泳，那么对于我们oo程序员来讲就非常简单了我们只需要在鸭父类中加一个游泳的方法，让会游泳的鸭子重写游泳方法就可以了。</p>
<p>c) 工厂模式：简单的工厂模式主要是统一提供实例对象的引用，通过工厂模式接口获取实例对象的引用。比如一个登陆功能，后端有三个类，controller类，interface类，实现接口的实现类。当客户端发出一个请求，当请求传到controller类中时，controller获取接口的引用对象，而实现接口的实现类中封装好了登陆的业务逻辑代码。当你需要加一个注册需求的时候只需要在接口类中加一个注册方法，实现类中实现方法，controller获取接口的引用对象即可，不需要改动原来的代码，这种做法是的可拓展性强。<br>参考链接</p>
<h2 id="48-Dubbo-的原理，数据怎么流转的，怎么实现集群，负载均衡，服务注册和发现。重试转发，快速失败的策略是怎样的。"><a href="#48-Dubbo-的原理，数据怎么流转的，怎么实现集群，负载均衡，服务注册和发现。重试转发，快速失败的策略是怎样的。" class="headerlink" title="48.Dubbo 的原理，数据怎么流转的，怎么实现集群，负载均衡，服务注册和发现。重试转发，快速失败的策略是怎样的。"></a>48.Dubbo 的原理，数据怎么流转的，怎么实现集群，负载均衡，服务注册和发现。重试转发，快速失败的策略是怎样的。</h2><p>Dubbo[]是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。<br>##Cluster 实现集群<br>在集群负载均衡时，Dubbo提供了多种均衡策略，缺省为random随机调用。<br>Random LoadBalance：随机，按权重比率设置随机概率。<br>RoundRobin LoadBalance：轮循，按公约后的权重比率设置轮循比率。<br>LeastActive LoadBalance：最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。<br>ConsistentHash LoadBalance：一致性Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。<br>快速失败，只发起一次调用，失败立即报错。<br>参考链接</p>
<h2 id="49-一次-RPC-请求的流程是什么。"><a href="#49-一次-RPC-请求的流程是什么。" class="headerlink" title="49.一次 RPC 请求的流程是什么。"></a>49.一次 RPC 请求的流程是什么。</h2><p>1）服务消费方（client）调用以本地调用方式调用服务；<br>2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；<br>3）client stub找到服务地址，并将消息发送到服务端；<br>4）server stub收到消息后进行解码；<br>5）server stub根据解码结果调用本地的服务；<br>6）本地服务执行并将结果返回给server stub；<br>7）server stub将返回结果打包成消息并发送至消费方；<br>8）client stub接收到消息，并进行解码；<br>9）服务消费方得到最终结果。</p>
<h2 id="50-异步模式的用途和意义。"><a href="#50-异步模式的用途和意义。" class="headerlink" title="50.异步模式的用途和意义。"></a>50.异步模式的用途和意义。</h2><p>异步模式使用与服务器多核，并发严重的场景<br>可提高服务吞吐量大，不容易受到冲击，可以采用并发策略，提高响应时间<br>缓存数据过期后的更新如何设计。<br>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。<br>命中：应用程序从cache中取数据，取到后返回。<br>更新：先把数据存到数据库中，成功后，再让缓存失效。</p>
<h2 id="51-编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用。"><a href="#51-编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用。" class="headerlink" title="51.编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用。"></a>51.编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用。</h2><p>开闭原则（Open Close Principle）<br>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。<br>里氏代换原则（Liskov Substitution Principle）<br>子类型必须能够替换掉它们的父类型。<br>依赖倒转原则（Dependence Inversion Principle）<br>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程<br>接口隔离原则（Interface Segregation Principle）<br>建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少<br>组合&#x2F;聚合复用原则<br>说要尽量的使用合成和聚合，而不是继承关系达到复用的目的<br>迪米特法则（Law Of Demeter）<br>迪米特法则其根本思想，是强调了类之间的松耦合，类之间的耦合越弱,越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成影响，也就是说，信息的隐藏促进了软件的复用。<br>单一职责原则（Single Responsibility Principle）<br>一个类只负责一项职责，应该仅有一个引起它变化的原因<br>参考链接</p>
<h2 id="52-设计一个社交网站中的“私信”功能，要求高并发、可扩展等等。-画一下架构图。"><a href="#52-设计一个社交网站中的“私信”功能，要求高并发、可扩展等等。-画一下架构图。" class="headerlink" title="52.设计一个社交网站中的“私信”功能，要求高并发、可扩展等等。 画一下架构图。"></a>52.设计一个社交网站中的“私信”功能，要求高并发、可扩展等等。 画一下架构图。</h2><p>MVC 模式，即常见的 MVC 框架。<br>SSM SSH SSI等<br>53.曾经参与设计的服务器架构。<br>54.应用服务器怎么监控性能，各种方式的区别。<br>55.如何设计一套高并发支付方案，架构如何设计。<br>56.如何实现负载均衡，有哪些算法可以实现。<br>57.Zookeeper 的用途，选举的原理是什么。<br>58.Mybatis 的底层实现原理。<br>59.请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存。<br>##请思考一个方案，实现分布式环境下的 countDownLatch。<br>60.后台系统怎么防止请求重复提交。<br>可以通过token值进行防止重复提交，存放到redis中，在表单初始化的时候隐藏在表单中，添加的时候在移除。判断这个状态即可防止重复提交。<br>如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点。本地缓存在并发使用时的注意事项。<br>61.描述一个服务从发布到被消费的详细过程。<br>##讲讲你理解的服务治理。<br>62.如何做到接口的幂等性。<br>#算法<br>63.10 亿个数字里里面找最小的 10 个。<br>##有 1 亿个数字，其中有 2 个是重复的，快速找到它，时间和空间要最优。<br>64.2 亿个随机生成的无序整数,找出中间大小的值。<br>65.给一个不知道长度的（可能很大）输入字符串，设计一种方案，将重复的字符排重。<br>66.遍历二叉树。<br>67.有 3n+1 个数字，其中 3n 个中是重复的，只有 1 个是不重复的，怎么找出来。<br>##常用的排序算法，快排，归并、冒泡。 快排的最优时间复杂度，最差复杂度。冒泡排序的优化方案。<br>##二分查找的时间复杂度，优势。<br>##一个已经构建好的 TreeSet，怎么完成倒排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mp</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">swap</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; a.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[i]) &#123;</span><br><span class="line">                swap = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = swap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**不使用递归的二分查找</span></span><br><span class="line"><span class="comment">			title:commonBinarySearch</span></span><br><span class="line"><span class="comment">         	*<span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     		*<span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">    		 *<span class="doctag">@return</span> 关键字位置</span></span><br><span class="line"><span class="comment">    	 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">commonBinarySearch</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//定义middle	 </span></span><br><span class="line">	<span class="keyword">if</span>(key &lt; arr[low] || key &gt; arr[high] || low &gt; high)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        middle = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[middle] &gt; key)&#123;</span><br><span class="line">            <span class="comment">//比关键字大则关键字在左区域</span></span><br><span class="line">            high = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[middle] &lt; key)&#123;</span><br><span class="line">            <span class="comment">//比关键字小则关键字在右区域</span></span><br><span class="line">            low = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//最后仍然没有找到，则返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用递归的二分查找</span></span><br><span class="line"><span class="comment"> *title:recursionBinarySearch</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@param</span> arr 有序数组</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@param</span> key 待查找关键字</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@return</span> 找到的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">recursionBinarySearch</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> key,<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(key &lt; arr[low] || key &gt; arr[high] || low &gt; high)&#123;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;				</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (low + high) / <span class="number">2</span>;<span class="comment">//初始中间位置</span></span><br><span class="line">	<span class="keyword">if</span>(arr[middle] &gt; key)&#123;</span><br><span class="line">		<span class="comment">//比关键字大则关键字在左区域</span></span><br><span class="line">		<span class="keyword">return</span> recursionBinarySearch(arr, key, low, middle - <span class="number">1</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[middle] &lt; key)&#123;</span><br><span class="line">		<span class="comment">//比关键字小则关键字在右区域</span></span><br><span class="line">		<span class="keyword">return</span> recursionBinarySearch(arr, key, middle + <span class="number">1</span>, high);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> middle;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>68.什么是 B+树，B-树，列出实际的使用场景。<br>69.并行和并发有什么区别？<br>并发当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间 段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。.这种方式我们称之为并发(Concurrent)。<br>并行：当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。<br>参考链接<br>70.线程和进程的区别？<br>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。<br>71.守护线程是什么？<br>守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。</p>
<ol start="72">
<li>创建线程有哪几种方式？<br>①. 继承Thread类创建线程类</li>
</ol>
<p>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。<br>创建Thread子类的实例，即创建了线程对象。<br>调用线程对象的start()方法来启动该线程。<br>②. 通过Runnable接口创建线程类</p>
<p>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。<br>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。<br>调用线程对象的start()方法来启动该线程。<br>③. 通过Callable和Future创建线程</p>
<p>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。<br>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。<br>使用FutureTask对象作为Thread对象的target创建并启动新线程。<br>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。<br>73. 说一下 runnable 和 callable 有什么区别？<br>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；<br>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。<br>74.线程有哪些状态？<br>线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。</p>
<p>创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。<br>就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。<br>运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。<br>阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。<br>死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 　　<br>75.sleep() 和 wait() 有什么区别？<br>sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。</p>
<p>wait()：wait()是Object的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程。<br>76.notify()和 notifyAll()有什么区别？<br>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。<br>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。<br>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。<br>77.线程的 run()和 start()有什么区别？<br>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。</p>
<p>start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</p>
<p>run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。<br>78.创建线程池有哪几种方式？<br>①. newFixedThreadPool(int nThreads)</p>
<p>创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</p>
<p>②. newCachedThreadPool()</p>
<p>创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。</p>
<p>③. newSingleThreadExecutor()</p>
<p>这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。</p>
<p>④. newScheduledThreadPool(int corePoolSize)</p>
<p>创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。<br>参考链接<br>79.线程池都有哪些状态？<br>线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。</p>
<p>线程池各个状态切换框架图：</p>
<p>80.线程池中 submit()和 execute()方法有什么区别？<br>接收的参数不一样<br>submit有返回值，而execute没有<br>submit方便Exception处理</p>
<p>81.在 java 程序中怎么保证多线程的运行安全？</p>
<p>线程安全在三个方面体现：</p>
<p>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；<br>可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；<br>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。<br>82.多线程锁的升级原理是什么？</p>
<p>在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。</p>
<p>锁升级的图示过程：</p>
<p>83.什么是死锁？<br>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。<br>84.ThreadLocal 是什么？有哪些使用场景？<br>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。<br>85.synchronized 和 Lock 有什么区别？<br>首先synchronized是java内置关键字，在jvm层面，Lock是个java类；<br>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；<br>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；<br>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；<br>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；<br>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。<br>86.对ajax的理解<br>Ajax为异步请求，即局部刷新技术，在传统的页面中，用户需要点击按钮或者事件触发请求，到刷新页面，而异步技术为不需要点击即可触发事件，这样使得用户体验感增强，比如商城购物车的异步加载，当你点击商品时无需请求后台而直接动态修改参数。</p>
<p>6.数据库知识<br>1.数据库隔离级别有哪些，各自的含义是什么，MYSQL 默认的隔离级别是是什么。</p>
<p>1.未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据<br>2.提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)<br>3.可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读<br>4.串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</p>
<p>MYSQL默认是RepeatedRead级别<br>1<br>2<br>3<br>4<br>5<br>6<br>2.MYSQL 有哪些存储引擎，各自优缺点。</p>
<p>1.MyISAM： 拥有较高的插入，查询速度，但不支持事务<br>2.InnoDB ：5.5版本后Mysql的默认数据库，事务型数据库的首选引擎，支持ACID事务，支持行级锁定<br>3.BDB： 源自Berkeley DB，事务型数据库的另一种选择，支持COMMIT和ROLLBACK等其他事务特性<br>4.Memory ：所有数据置于内存的存储引擎，拥有极高的插入，更新和查询效率。但是会占用和数据量成正比的内存空间。并且其内容会在Mysql重新启动时丢失<br>5.Merge ：将一定数量的MyISAM表联合而成一个整体，在超大规模数据存储时很有用<br>6.Archive ：非常适合存储大量的独立的，作为历史记录的数据。因为它们不经常被读取。Archive拥有高效的插入速度，但其对查询的支持相对较差<br>7.Federated： 将不同的Mysql服务器联合起来，逻辑上组成一个完整的数据库。非常适合分布式应用<br>8.Cluster&#x2F;NDB ：高冗余的存储引擎，用多台数据机器联合提供服务以提高整体性能和安全性。适合数据量大，安全和性能要求高的应用<br>9.CSV： 逻辑上由逗号分割数据的存储引擎。它会在数据库子目录里为每个数据表创建一个.CSV文件。这是一种普通文本文件，每个数据行占用一个文本行。CSV存储引擎不支持索引。<br>10.BlackHole ：黑洞引擎，写入的任何数据都会消失，一般用于记录binlog做复制的中继</p>
<p>另外，Mysql的存储引擎接口定义良好。有兴趣的开发者通过阅读文档编写自己的存储引擎。<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>参考链接<br>3.高并发下，如何做到安全的修改同一行数据。<br>使用悲观锁 悲观锁本质是当前只有一个线程执行操作，结束了唤醒其他线程进行处理。<br>也可以缓存队列中锁定主键。<br>4.乐观锁和悲观锁是什么，INNODB 的行级锁有哪 2 种，解释其含义。<br>乐观锁是设定每次修改都不会冲突，只在提交的时候去检查，悲观锁设定每次修改都会冲突，持有排他锁。<br>行级锁分为共享锁和排他锁两种 共享锁又称读锁 排他锁又称写锁<br>参考链接<br>5.SQL 优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。<br>查看慢日志（show [session|gobal] status ），定位慢查询，查看慢查询执行计划 根据执行计划确认优化方案<br>Explain sql<br>select_type:表示select类型。常见的取值有SIMPLE（简单表，即不使用连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（union中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个SELECT）等。<br>talbe：输出结果集的表。<br>type:表的连接类型。性能由高到底：system（表中仅有一行）、const（表中最多有一个匹配行）、eq_ref、ref、ref_null、index_merge、unique_subquery、index_subquery、range、idnex等<br>possible_keys:查询时，可能使用的索引<br>key:实际使用的索引<br>key_len:索引字段的长度<br>rows：扫描行的数量<br>Extra：执行情况的说明和描述<br>Oracle优化</p>
<p>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
<p>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<p>select id from t where num is null<br>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：<br>select id from t where num&#x3D;0<br>3.应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。<br>4.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：<br>select id from t where num&#x3D;10 or num&#x3D;20<br>可以这样查询：<br>select id from t where num&#x3D;10<br>union all<br>select id from t where num&#x3D;20<br>5.in 和 not in 也要慎用，否则会导致全表扫描，如：<br>select id from t where num in(1,2,3)<br>对于连续的数值，能用 between 就不要用 in 了：<br>select id from t where num between 1 and 3<br>6.下面的查询也将导致全表扫描：<br>select id from t where name like ‘%abc%’<br>若要提高效率，可以考虑全文检索。<br>7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：<br>select id from t where num&#x3D;@num<br>可以改为强制查询使用索引：<br>select id from t with(index(索引名)) where num&#x3D;@num<br>8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：<br>select id from t where num&#x2F;2&#x3D;100<br>应改为:<br>select id from t where num&#x3D;100*2<br>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：<br>select id from t where substring(name,1,3)&#x3D;‘abc’ &#x2F;&#x2F; oracle总有的是substr函数。<br>select id from t where datediff(day,createdate,‘2005-11-30’)&#x3D;0 &#x2F;&#x2F;查过了确实没有datediff函数。<br>应改为:<br>select id from t where name like ‘abc%’<br>select id from t where createdate&gt;&#x3D;‘2005-11-30’ and createdate&lt;‘2005-12-1’ &#x2F;&#x2F;<br>oracle 中时间应该把char 转换成 date 如： createdate &gt;&#x3D; to_date(‘2005-11-30’,‘yyyy-mm-dd’)<br>10.不要在 where 子句中的“&#x3D;”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
<p>11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。<br>12.不要写一些没有意义的查询，如需要生成一个空表结构：<br>select col1,col2 into #t from t where 1&#x3D;0<br>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：<br>create table #t(…)<br>13.很多时候用 exists 代替 in 是一个好的选择：<br>select num from a where num in(select num from b)<br>用下面的语句替换：<br>select num from a where exists(select 1 from b where num&#x3D;a.num)<br>14.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。<br>15.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。<br>16.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。<br>17.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。<br>18.尽可能的使用 varchar&#x2F;nvarchar 代替 char&#x2F;nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。<br>19.任何地方都不要使用 select * from t ，用具体的字段列表代替“<em>”，不要返回用不到的任何字段。<br>20.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。<br>21.避免频繁创建和删除临时表，以减少系统表资源的消耗。<br>22.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。<br>23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。<br>24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。<br>25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。<br>26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。<br>27.与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。<br>28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。<br>29.尽量避免大事务操作，提高系统并发能力。<br>30.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>参考链接1<br>参考链接2<br>6.数据库会死锁吗，举一个死锁的例子，mysql 怎么解决死锁。<br>产生死锁的原因主要是：<br>（1）系统资源不足。<br>（2） 进程运行推进的顺序不合适。<br>（3）资源分配不当等。<br>如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。<br>产生死锁的四个必要条件：<br>（1） 互斥条件：一个资源每次只能被一个进程使用。<br>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。<br>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。<br>这里提供两个解决数据库死锁的方法：<br>1）重启数据库（谁用谁知道）<br>2）杀掉抢资源的进程：<br>先查哪些进程在抢资源：SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;<br>杀掉它们：Kill trx_mysql_thread_id；<br>7.MYsql 的索引原理，索引的类型有哪些，如何创建合理的索引，索引如何优化。<br>索引是通过复杂的算法，提高数据查询性能的手段。从磁盘io到内存io的转变<br>普通索引，主键，唯一，单列&#x2F;多列索引建索引的几大原则<br>1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。<br>2.&#x3D;和in可以乱序，比如a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式<br>3.尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)&#x2F;count(</em>)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录<br>4.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) &#x3D; ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time &#x3D; unix_timestamp(’2014-05-29’);<br>5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可<br>参考链接1<br>参考链接2<br>##聚集索引和非聚集索引的区别。<br>“聚簇”就是索引和记录紧密在一起。<br>非聚簇索引 索引文件和数据文件分开存放，索引文件的叶子页只保存了主键值，要定位记录还要去查找相应的数据块。<br>8.数据库中 BTREE 和 B+tree 区别。<br>B+是btree的变种，本质都是btree，btree+与B-Tree相比，B+Tree有以下不同点：<br>每个节点的指针上限为2d而不是2d+1。<br>内节点不存储data，只存储key；叶子节点不存储指针。<br>参考链接<br>Btree 怎么分裂的，什么时候分裂，为什么是平衡的。<br>Key 超过1024才分裂B树为甚会分裂？ 因为随着数据的增多，一个结点的key满了，为了保持B树的特性，就会产生分裂，就向红黑树和AVL树为了保持树的性质需要进行旋转一样！<br>9.ACID 是什么。<br>A，atomic，原子性，要么都提交，要么都失败，不能一部分成功，一部分失败。<br>C，consistent，一致性，事物开始及结束后，数据的一致性约束没有被破坏<br>I，isolation，隔离性，并发事物间相互不影响，互不干扰。<br>D，durability,持久性，已经提交的事物对数据库所做的更新必须永久保存。即便发生崩溃，也不能被回滚或数据丢失。<br>##Mysql 怎么优化 table scan 的。<br>避免在where子句中对字段进行is null判断<br>应尽量避免在where 子句中使用!&#x3D;或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。<br>避免在where 子句中使用or 来连接条件<br>in 和not in 也要慎用<br>Like查询（非左开头）<br>使用NUM&#x3D;@num参数这种<br>where 子句中对字段进行表达式操作num&#x2F;2&#x3D;XX<br>在where子句中对字段进行函数操作<br>10.如何写 sql 能够有效的使用到复合索引。<br>由于复合索引的组合索引，类似多个木板拼接在一起，如果中间断了就无法用了，所以要能用到复合索引，首先开头(第一列)要用上，比如index(a,b) 这种，我们可以select table tname where a&#x3D;XX 用到第一列索引 如果想用第二列 可以 and b&#x3D;XX 或者and b like‘TTT%’<br>11.mysql 中 in 和 exists 区别。<br>mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。<br>如果查询的两个表大小相当，那么用in和exists差别不大。<br>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in：<br>not in 和not exists如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。<br>1.EXISTS只返回TRUE或FALSE，不会返回UNKNOWN。<br>2.IN当遇到包含NULL的情况，那么就会返回UNKNOWN。<br>12.数据库自增主键可能的问题。<br>在分库分表时可能会生成重复主键 利用自增比例达到唯一 自增1 2,3 等<br>参考链接<br>#消息队列<br>##用过哪些 MQ，和其他 mq 比较有什么优缺点，MQ 的连接是线程安全的吗，你们公司的MQ 服务架构怎样的。<br>根据实际情况说明<br>我们公司用activeMQ 因为业务比较简单 只有转码功能，而amq比较简单<br>如果是分布式的建议用kafka<br>参考链接<br>13.MQ 系统的数据如何保证不丢失。<br>基本都是对数据进行持久化，多盘存储<br>14.rabbitmq 如何实现集群高可用。<br>集群是保证服务可靠性的一种方式，同时可以通过水平扩展以提升消息吞吐能力。RabbitMQ是用分布式程序设计语言erlang开发的，所以天生就支持集群。接下来，将介绍RabbitMQ分布式消息处理方式、集群模式、节点类型，并动手搭建一个高可用集群环境，最后通过java程序来验证集群的高可用性。<br>三种分布式消息处理方式<br>RabbitMQ分布式的消息处理方式有以下三种：<br>1、Clustering：不支持跨网段，各节点需运行同版本的Erlang和RabbitMQ, 应用于同网段局域网。<br>2、Federation：允许单台服务器上的Exchange或Queue接收发布到另一台服务器上Exchange或Queue的消息, 应用于广域网，。<br>3、Shovel：与Federation类似，但工作在更低层次。<br>RabbitMQ对网络延迟很敏感，在LAN环境建议使用clustering方式;在WAN环境中，则使用Federation或Shovel。我们平时说的RabbitMQ集群，说的就是clustering方式，它是RabbitMQ内嵌的一种消息处理方式，而Federation或Shovel则是以plugin形式存在。<br>参考链接1<br>参考链接2<br>#Redis，Memcached<br>15.redis 的 list 结构相关的操作。<br>LPUSH LPUSHX RPUSH RPUSHX LPOP RPOP BLPOP BRPOP LLEN LRANGE<br>参考链接<br>16.Redis 的数据结构都有哪些。<br>字符串(strings)：存储整数（比如计数器）和字符串（废话。。），有些公司也用来存储json&#x2F;pb等序列化数据，并不推荐，浪费内存<br>哈希表(hashes)：存储配置，对象（比如用户、商品），优点是可以存取部分key，对于经常变化的或者部分key要求atom操作的适合<br>列表(lists)：可以用来存最新用户动态，时间轴，优点是有序，确定是元素可重复，不去重<br>集合(sets)：无序，唯一，对于要求严格唯一性的可以使用<br>有序集合(sorted sets)：集合的有序版，很好用，对于排名之类的复杂场景可以考虑<br>参考链接<br>##Redis 的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。<br>持久化方式：RDB时间点快照 AOF记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。<br>内存设置 maxmemory used_memory<br>虚拟内存： vm-enabled yes<br>3.0采用Cluster方式，<br>Redis集群相对单机在功能上存在一些限制， 需要开发人员提前了解，<br>在使用时做好规避。 限制如下：<br>1） key批量操作支持有限。 如mset、 mget， 目前只支持具有相同slot值的<br>ke<br>y执<br>行批量操作。 对于映射为不同slot值的key由于执行mget、 mget等操作可<br>能存在于多个节点上因此不被支持。<br>2） key事务操作支持有限。 同理只支持多key在同一节点上的事务操<br>作， 当多个key分布在不同的节点上时无法使用事务功能。<br>3） key作为数据分区的最小粒度， 因此不能将一个大的键值对象如<br>ha<br>sh、 list等映射到不同的节点。<br>4） 不支持多数据库空间。 单机下的Redis可以支持16个数据库， 集群模<br>式下只能使用一个数据库空间， 即db0。<br>5） 复制结构只支持一层， 从节点只能复制主节点， 不支持嵌套树状复<br>制结构。<br>Redis Cluster是Redis的分布式解决方案， 在3.0版本正式推出， 有效地解<br>决了Redis分布式方面的需求。 当遇到单机内存、 并发、 流量等瓶颈时， 可<br>以采用Cluster架构方案达到负载均衡的目的。 之前， Redis分布式方案一般<br>有两种：<br>·客户端分区方案， 优点是分区逻辑可控， 缺点是需要自己处理数据路<br>由、 高可用、 故障转移等问题。<br>·代理方案， 优点是简化客户端分布式逻辑和升级维护便利， 缺点是加<br>重架构部署复杂度和性能损耗。<br>现在官方为我们提供了专有的集群方案： Redis Cluster， 它非常优雅地<br>解决了Redis集群方面的问题， 因此理解应用好Redis Cluster将极大地解放我<br>们使用分布式Redis的工作量， 同时它也是学习分布式存储的绝佳案例。<br>LRU(近期最少使用算法)TTL（超时算法） 去除ttl最大的键值<br>参考链接1<br>参考链接2<br>参考链接3<br>17.redis2 和 redis3 的区别，redis3 内部通讯机制。<br>集群方式的区别，3采用Cluster，2采用客户端分区方案和代理方案<br>通信过程说明：<br>1） 集群中的每个节点都会单独开辟一个TCP通道， 用于节点之间彼此<br>通信， 通信端口号在基础端口上加10000。<br>2） 每个节点在固定周期内通过特定规则选择几个节点发送ping消息。<br>3） 接收到ping消息的节点用pong消息作为响应。<br>##当前 redis 集群有哪些玩法，各自优缺点，场景。<br>当缓存使用 持久化使用<br>18.Memcache 的原理，哪些数据适合放在缓存中。<br>基于libevent的事件处理<br>内置内存存储方式SLab Allocation机制<br>并不单一的数据删除机制<br>基于客户端的分布式系统<br>变化频繁，具有不稳定性的数据,不需要实时入库, (比如用户在线<br>状态、在线人数…)<br>门户网站的新闻等，觉得页面静态化仍不能满足要求，可以放入<br>到memcache中.(配合jquey的ajax请求)<br>##redis 和 memcached 的内存管理的区别。<br>Memcached默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题。<br>Redis的内存管理主要通过源码中zmalloc.h和zmalloc.c两个文件来实现的。<br>在Redis中，并不是所有的数据都一直存储在内存中的。这是和Memcached相比一个最大的区别。<br>参考链接<br>19.Redis 的并发竞争问题如何解决，了解 Redis 事务的 CAS 操作吗。<br>Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：<br>1.客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。<br>2.服务器角度，利用setnx实现锁。<br>MULTI，EXEC，DISCARD，WATCH 四个命令是 Redis 事务的四个基础命令。其中：<br>MULTI，告诉 Redis 服务器开启一个事务。注意，只是开启，而不是执行<br>EXEC，告诉 Redis 开始执行事务<br>DISCARD，告诉 Redis 取消事务<br>WATCH，监视某一个键值对，它的作用是在事务执行之前如果监视的键值被修改，事务会被取消。<br>可以利用watch实现cas乐观锁<br>参考链接1<br>参考链接2<br>##Redis 的选举算法和流程是怎样的<br>Raft采用心跳机制触发Leader选举。系统启动后，全部节点初始化为Follower，term为0.节点如果收到了RequestVote或者AppendEntries，就会保持自己的Follower身份。如果一段时间内没收到AppendEntries消息直到选举超时，说明在该节点的超时时间内还没发现Leader，Follower就会转换成Candidate，自己开始竞选Leader。一旦转化为Candidate，该节点立即开始下面几件事情：<br>1、增加自己的term。<br>2、启动一个新的定时器。<br>3、给自己投一票。<br>4、向所有其他节点发送RequestVote，并等待其他节点的回复。<br>如果在这过程中收到了其他节点发送的AppendEntries，就说明已经有Leader产生，自己就转换成Follower，选举结束。<br>如果在计时器超时前，节点收到多数节点的同意投票，就转换成Leader。同时向所有其他节点发送AppendEntries，告知自己成为了Leader。<br>每个节点在一个term内只能投一票，采取先到先得的策略，Candidate前面说到已经投给了自己，Follower会投给第一个收到RequestVote的节点。每个Follower有一个计时器，在计时器超时时仍然没有接受到来自Leader的心跳RPC, 则自己转换为Candidate, 开始请求投票，就是上面的的竞选Leader步骤。<br>如果多个Candidate发起投票，每个Candidate都没拿到多数的投票（Split Vote），那么就会等到计时器超时后重新成为Candidate，重复前面竞选Leader步骤。<br>Raft协议的定时器采取随机超时时间，这是选举Leader的关键。每个节点定时器的超时时间随机设置，随机选取配置时间的1倍到2倍之间。由于随机配置，所以各个Follower同时转成Candidate的时间一般不一样，在同一个term内，先转为Candidate的节点会先发起投票，从而获得多数票。多个节点同时转换为Candidate的可能性很小。即使几个Candidate同时发起投票，在该term内有几个节点获得一样高的票数，只是这个term无法选出Leader。由于各个节点定时器的超时时间随机生成，那么最先进入下一个term的节点，将更有机会成为Leader。连续多次发生在一个term内节点获得一样高票数在理论上几率很小，实际上可以认为完全不可能发生。一般1-2个term类，Leader就会被选出来。<br>Sentinel的选举流程<br>Sentinel集群正常运行的时候每个节点epoch相同，当需要故障转移的时候会在集群中选出Leader执行故障转移操作。Sentinel采用了Raft协议实现了Sentinel间选举Leader的算法，不过也不完全跟论文描述的步骤一致。Sentinel集群运行过程中故障转移完成，所有Sentinel又会恢复平等。Leader仅仅是故障转移操作出现的角色。<br>选举流程<br>1、某个Sentinel认定master客观下线的节点后，该Sentinel会先看看自己有没有投过票，如果自己已经投过票给其他Sentinel了，在2倍故障转移的超时时间自己就不会成为Leader。相当于它是一个Follower。<br>2、如果该Sentinel还没投过票，那么它就成为Candidate。<br>3、和Raft协议描述的一样，成为Candidate，Sentinel需要完成几件事情<br>1）更新故障转移状态为start<br>2）当前epoch加1，相当于进入一个新term，在Sentinel中epoch就是Raft协议中的term。<br>3）更新自己的超时时间为当前时间随机加上一段时间，随机时间为1s内的随机毫秒数。<br>4）向其他节点发送is-master-down-by-addr命令请求投票。命令会带上自己的epoch。<br>5）给自己投一票，在Sentinel中，投票的方式是把自己master结构体里的leader和leader_epoch改成投给的Sentinel和它的epoch。<br>4、其他Sentinel会收到Candidate的is-master-down-by-addr命令。如果Sentinel当前epoch和Candidate传给他的epoch一样，说明他已经把自己master结构体里的leader和leader_epoch改成其他Candidate，相当于把票投给了其他Candidate。投过票给别的Sentinel后，在当前epoch内自己就只能成为Follower。<br>5、Candidate会不断的统计自己的票数，直到他发现认同他成为Leader的票数超过一半而且超过它配置的quorum（quorum可以参考《redis sentinel设计与实现》）。Sentinel比Raft协议增加了quorum，这样一个Sentinel能否当选Leader还取决于它配置的quorum。<br>6、如果在一个选举时间内，Candidate没有获得超过一半且超过它配置的quorum的票数，自己的这次选举就失败了。<br>7、如果在一个epoch内，没有一个Candidate获得更多的票数。那么等待超过2倍故障转移的超时时间后，Candidate增加epoch重新投票。<br>8、如果某个Candidate获得超过一半且超过它配置的quorum的票数，那么它就成为了Leader。<br>9、与Raft协议不同，Leader并不会把自己成为Leader的消息发给其他Sentinel。其他Sentinel等待Leader从slave选出master后，检测到新的master正常工作后，就会去掉客观下线的标识，从而不需要进入故障转移流程。<br>参考链接<br>20.redis 的持久化的机制，aof 和 rdb 的区别。<br>RDB 定时快照方式(snapshot)： 定时备份，可能会丢失数据<br>AOF 基于语句追加方式 只追加写操作<br>AOF 持久化和 RDB 持久化的最主要区别在于，前者记录了数据的变更，而后者是保存了数据本身<br>21.redis 的集群怎么同步的数据的。<br>redis replication redis-migrate-tool等方式<br>#搜索<br>22.elasticsearch 了解多少，说说你们公司 es 的集群架构，索引数据大小，分片有多少，以及一些调优手段。elasticsearch 的倒排索引是什么。<br>ElasticSearch（简称ES）是一个分布式、Restful的搜索及分析服务器，设计用于分布式计算；能够达到实时搜索，稳定，可靠，快速。和Apache Solr一样，它也是基于Lucence的索引服务器，而ElasticSearch对比Solr的优点在于：</p>
<p>1.轻量级：安装启动方便，下载文件之后一条命令就可以启动。<br>2.Schema free：可以向服务器提交任意结构的JSON对象，Solr中使用schema.xml指定了索引结构。<br>3.多索引文件支持：使用不同的index参数就能创建另一个索引文件，Solr中需要另行配置。<br>4.分布式：Solr Cloud的配置比较复杂。<br>1<br>2<br>3<br>4<br>倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。倒排索引主要由两个部分组成：“单词词典”和“倒排文件”。<br>##elasticsearch 索引数据多了怎么办，如何调优，部署。<br>使用bulk API<br>初次索引的时候，把 replica 设置为 0<br>增大 threadpool.index.queue_size<br>增大 indices.memory.index_buffer_size<br>增大 index.translog.flush_threshold_ops<br>增大 index.translog.sync_interval<br>增大 index.engine.robin.refresh_interval<br>参考链接<br>23.lucence 内部结构是什么<br>索引(Index)：<br>在Lucene中一个索引是放在一个文件夹中的。<br>如上图，同一文件夹中的所有的文件构成一个Lucene索引。<br>段(Segment)：<br>一个索引可以包含多个段，段与段之间是独立的，添加新文档可以生成新的段，不同的段可以合并。<br>如上图，具有相同前缀文件的属同一个段，图中共三个段 “_0” 和 “_1”和“_2”。<br>segments.gen和segments_X是段的元数据文件，也即它们保存了段的属性信息。<br>文档(Document)：<br>文档是我们建索引的基本单位，不同的文档是保存在不同的段中的，一个段可以包含多篇文档。<br>新添加的文档是单独保存在一个新生成的段中，随着段的合并，不同的文档合并到同一个段中。<br>域(Field)：<br>一篇文档包含不同类型的信息，可以分开索引，比如标题，时间，正文，作者等，都可以保存在不同的域里。<br>不同域的索引方式可以不同，在真正解析域的存储的时候，我们会详细解读。<br>词(Term)：<br>词是索引的最小单位，是经过词法分析和语言处理后的字符串。</p>
<p>7.最后附一遍持续整理的博客<br>彩蛋链接</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">郑 则弘</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://myzzh1231.github.io/zzhBlog.github.io/2023/03/09/1.JAVA%E5%9F%BA%E7%A1%80/">https://myzzh1231.github.io/zzhBlog.github.io/2023/03/09/1.JAVA%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://myzzh1231.github.io/zzhBlog.github.io" target="_blank">zzhBlog</a>！</span></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="/zzhBlog.github.io/images/background.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/zzhBlog.github.io/2023/03/09/CSS/"><img class="prev-cover" src="/zzhBlog.github.io/images/background.jpg" onerror="onerror=null;src='/zzhBlog.github.io/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">css基础学习</div></div></a></div><div class="next-post pull-right"><a href="/zzhBlog.github.io/2023/03/09/SpringCloud/"><img class="next-cover" src="/zzhBlog.github.io/images/background.jpg" onerror="onerror=null;src='/zzhBlog.github.io/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">springcloud</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-JAVA%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">1.JAVA基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-JAVA%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%90%84%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1.JAVA中的几种基本类型，各占用多少字节？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-String%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">2.String能被继承吗？为什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String-str-x3D-%E2%80%9Cabc%E2%80%9D%E5%92%8CString-str-x3D-new-String-%E2%80%9Cabc%E2%80%9D-%E4%BA%A7%E7%94%9F%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">String str&#x3D;“abc”和String str&#x3D;new String(“abc”); 产生几个对象？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-String%EF%BC%8C-Stringbuffer%EF%BC%8C-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">1.3.</span> <span class="toc-text">3.String， Stringbuffer， StringBuilder 的区别。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-ArrayList-%E5%92%8C-LinkedList-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">1.4.</span> <span class="toc-text">4.ArrayList 和 LinkedList 有什么区别。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E5%92%8CLinkedList%E9%83%BD%E5%AE%9E%E7%8E%B0%E4%BA%86List%E6%8E%A5%E5%8F%A3%EF%BC%8C%E6%9C%89%E4%BB%A5%E4%B8%8B%E7%9A%84%E4%B8%8D%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="toc-number">1.4.1.</span> <span class="toc-text">ArrayList和LinkedList都实现了List接口，有以下的不同点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%AE%B2%E8%AE%B2%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%EF%BC%8C%E6%AF%94%E5%A6%82%E7%88%B6%E7%B1%BB%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%AD%90%E7%B1%BB%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%BD%93-new-%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C-%E4%BB%96%E4%BB%AC%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E3%80%82"><span class="toc-number">1.5.</span> <span class="toc-text">5.讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当 new 的时候， 他们的执行顺序。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B-Map-%E7%B1%BB%EF%BC%8C%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8CHashMap-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97-%E5%B9%B6%E5%8F%91%E4%B8%8B%E4%BD%BF%E7%94%A8%E7%9A%84-Map-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BB%96%E4%BB%AC%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%AF%94%E5%A6%82%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%EF%BC%8C-hashcode%EF%BC%8C%E6%89%A9%E5%AE%B9%EF%BC%8C-%E9%BB%98%E8%AE%A4%E5%AE%B9%E9%87%8F%E7%AD%89%E3%80%82"><span class="toc-number">1.6.</span> <span class="toc-text">6.用过哪些 Map 类，都有什么区别，HashMap 是线程安全的吗,并发下使用的 Map 是什么，他们内部原理分别是什么，比如存储方式， hashcode，扩容， 默认容量等。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%9C%89%E6%B2%A1%E6%9C%89%E6%9C%89%E9%A1%BA%E5%BA%8F%E7%9A%84-Map-%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%8C-%E5%A6%82%E6%9E%9C%E6%9C%89%EF%BC%8C-%E4%BB%96%E4%BB%AC%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E7%9A%84%E3%80%82"><span class="toc-number">1.7.</span> <span class="toc-text">7.有没有有顺序的 Map 实现类， 如果有， 他们是怎么保证有序的。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E7%B1%BB%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%A4%9A%E4%B8%AA%E7%B1%BB%E4%B9%88%EF%BC%8C%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3%E4%B9%88-%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3%E4%B9%88%E3%80%82"><span class="toc-number">1.8.</span> <span class="toc-text">8.抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E7%BB%A7%E6%89%BF%E5%92%8C%E8%81%9A%E5%90%88%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%E3%80%82"><span class="toc-number">1.9.</span> <span class="toc-text">9.继承和聚合的区别在哪。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E8%AE%B2%E8%AE%B2%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84-nio%E5%92%8C-bio-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E5%95%A5%EF%BC%8C%E8%B0%88%E8%B0%88-reactor-%E6%A8%A1%E5%9E%8B%E3%80%82"><span class="toc-number">1.10.</span> <span class="toc-text">10.讲讲你理解的 nio和 bio 的区别是啥，谈谈 reactor 模型。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8C%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.11.</span> <span class="toc-text">11.反射的原理，反射创建类实例的三种方式是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%8F%8D%E5%B0%84%E4%B8%AD%EF%BC%8CClass-forName-%E5%92%8C-ClassLoader-%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">1.12.</span> <span class="toc-text">12.反射中，Class.forName 和 ClassLoader 区别。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E6%8F%8F%E8%BF%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%88%86%E5%88%AB%E8%AF%B4%E5%87%BA%E7%9B%B8%E5%BA%94%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E3%80%82"><span class="toc-number">1.13.</span> <span class="toc-text">13.描述动态代理的几种实现方式，分别说出相应的优缺点。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E4%B8%BA%E4%BB%80%E4%B9%88-CGlib-%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E5%AF%B9%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%90%86%E3%80%82"><span class="toc-number">1.14.</span> <span class="toc-text">14.为什么 CGlib 方式可以对接口实现代理。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-final-%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">1.15.</span> <span class="toc-text">15.final 的用途</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E5%86%99%E5%87%BA%E4%B8%89%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E3%80%82"><span class="toc-number">1.16.</span> <span class="toc-text">16.写出三种单例模式实现。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E5%A6%82%E4%BD%95%E5%9C%A8%E7%88%B6%E7%B1%BB%E4%B8%AD%E4%B8%BA%E5%AD%90%E7%B1%BB%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90%E6%89%80%E6%9C%89%E7%9A%84-hashcode-%E5%92%8C-equals-%E5%AE%9E%E7%8E%B0%EF%BC%9F%E8%BF%99%E4%B9%88%E5%81%9A%E6%9C%89%E4%BD%95%E4%BC%98%E5%8A%A3%E3%80%82"><span class="toc-number">1.17.</span> <span class="toc-text">17.如何在父类中为子类自动完成所有的 hashcode 和 equals 实现？这么做有何优劣。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E8%AF%B7%E7%BB%93%E5%90%88-OO-%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%EF%BC%8C%E8%B0%88%E8%B0%88%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-public%E3%80%81private%E3%80%81protected%E3%80%81default-%E5%9C%A8%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82"><span class="toc-number">1.18.</span> <span class="toc-text">18.请结合 OO 设计理念，谈谈访问修饰符 public、private、protected、default 在应用设计中的作用。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">1.19.</span> <span class="toc-text">19.深拷贝和浅拷贝区别。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.20.</span> <span class="toc-text">20.数组和链表数据结构描述，各自的时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-error-%E5%92%8C-exception-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8CCheckedException%EF%BC%8CRuntimeException-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.21.</span> <span class="toc-text">21.error 和 exception 的区别，CheckedException，RuntimeException 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E8%AF%B7%E5%88%97%E5%87%BA-5-%E4%B8%AA%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E3%80%82"><span class="toc-number">1.22.</span> <span class="toc-text">22.请列出 5 个运行时异常。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-java-lang-String-%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">1.23.</span> <span class="toc-text">23.在自己的代码中，如果创建一个 java.lang.String 对象，这个对象是否可以被类加载器加载？为什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E5%AF%B9-java-lang-Object-%E5%AF%B9%E8%B1%A1%E4%B8%AD-hashCode-%E5%92%8C-equals-%E6%96%B9%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%82%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E5%AE%9E%E7%8E%B0%E8%BF%99%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">1.24.</span> <span class="toc-text">24.说一说你对 java.lang.Object 对象中 hashCode 和 equals 方法的理解。在什么场景下需要重新实现这两个方法。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E5%9C%A8-jdk1-5-%E4%B8%AD%EF%BC%8C%E5%BC%95%E5%85%A5%E4%BA%86%E6%B3%9B%E5%9E%8B%EF%BC%8C%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AD%98%E5%9C%A8%E6%98%AF%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E3%80%82"><span class="toc-number">1.25.</span> <span class="toc-text">25.在 jdk1.5 中，引入了泛型，泛型的存在是用来解决什么问题。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E8%BF%99%E6%A0%B7%E7%9A%84-a-hashcode-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%8C%E4%B8%8E-a-equals-b-%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%E3%80%82"><span class="toc-number">1.26.</span> <span class="toc-text">26.这样的 a.hashcode() 有什么用，与 a.equals(b)有什么关系。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E6%9C%89%E6%B2%A1%E6%9C%89%E5%8F%AF%E8%83%BD-2-%E4%B8%AA%E4%B8%8D%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84-hashcode%E3%80%82"><span class="toc-number">1.27.</span> <span class="toc-text">27.有没有可能 2 个不相等的对象有相同的 hashcode。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-Java-%E4%B8%AD%E7%9A%84-HashSet-%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%E3%80%82"><span class="toc-number">1.28.</span> <span class="toc-text">28.Java 中的 HashSet 内部是如何工作的。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-JDK-%E5%92%8C-JRE-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.29.</span> <span class="toc-text">29.JDK 和 JRE 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-x3D-x3D-%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.30.</span> <span class="toc-text">30.&#x3D;&#x3D; 和 equals 的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-java-%E4%B8%AD%E7%9A%84-Math-round-1-5-%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">1.31.</span> <span class="toc-text">31.java 中的 Math.round(-1.5) 等于多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E5%86%99%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%E5%87%BD%E6%95%B0%E3%80%82"><span class="toc-number">1.32.</span> <span class="toc-text">32.写一个字符串反转函数。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-String-%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E9%83%BD%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.33.</span> <span class="toc-text">33.String 类的常用方法都有那些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%BF%85%E9%A1%BB%E8%A6%81%E6%9C%89%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F"><span class="toc-number">1.34.</span> <span class="toc-text">34.抽象类必须要有抽象方法吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-java-%E4%B8%AD-IO-%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">1.35.</span> <span class="toc-text">35.java 中 IO 流分为几种？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-List%E3%80%81Set%E3%80%81Map-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.36.</span> <span class="toc-text">37.List、Set、Map 之间的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%92%8C-List-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-number">1.37.</span> <span class="toc-text">38.如何实现数组和 List 之间的转换？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-ArrayList-%E5%92%8C-Vector-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.38.</span> <span class="toc-text">39.ArrayList 和 Vector 的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-Array-%E5%92%8C-ArrayList-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.39.</span> <span class="toc-text">40.Array 和 ArrayList 有何区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E5%93%AA%E4%BA%9B%E9%9B%86%E5%90%88%E7%B1%BB%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">1.40.</span> <span class="toc-text">42.哪些集合类是线程安全的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.41.</span> <span class="toc-text">43.迭代器 Iterator 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-Iterator-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">1.42.</span> <span class="toc-text">44.Iterator 怎么使用？有什么特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-Iterator-%E5%92%8C-ListIterator-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.43.</span> <span class="toc-text">45.Iterator 和 ListIterator 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-synchronized-%E5%92%8C-volatile-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.44.</span> <span class="toc-text">46.synchronized 和 volatile 的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%96%87%E6%9C%AC-%E8%8E%B7%E5%8F%96%E6%9F%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-number">1.45.</span> <span class="toc-text">47.给定一个文本,获取某字符串出现的次数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-JVM-%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">2.JVM 知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E3%80%82"><span class="toc-number">2.1.</span> <span class="toc-text">1.什么情况下会发生栈内存溢出。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-JVM-%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%8CEden-%E5%92%8C-Survivor-%E6%AF%94%E4%BE%8B%E3%80%82"><span class="toc-number">2.2.</span> <span class="toc-text">2.JVM 的内存结构，Eden 和 Survivor 比例。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E5%87%A0%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%8C%E9%87%8D%E7%82%B9%E8%AE%B2%E4%B8%8B-cms%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%8E%9F%E7%90%86%EF%BC%8C%E6%B5%81%E7%A8%8B%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.3.</span> <span class="toc-text">4.你知道哪几种垃圾收集器，各自的优缺点，重点讲下 cms，包括原理，流程，优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E3%80%82"><span class="toc-number">2.4.</span> <span class="toc-text">5.垃圾回收算法的实现原理。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%BD%93%E5%87%BA%E7%8E%B0%E4%BA%86%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%8C%E4%BD%A0%E6%80%8E%E4%B9%88%E6%8E%92%E9%94%99%E3%80%82"><span class="toc-number">2.5.</span> <span class="toc-text">6.当出现了内存溢出，你怎么排错。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%8C%E6%AF%94%E5%A6%82%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%EF%BC%8Chappen-before%EF%BC%8C%E4%B8%BB%E5%86%85%E5%AD%98%EF%BC%8C%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E7%AD%89%E3%80%82"><span class="toc-number">2.6.</span> <span class="toc-text">7.JVM 内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E3%80%82"><span class="toc-number">2.7.</span> <span class="toc-text">8.简单说说你了解的类加载器。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E8%AE%B2%E8%AE%B2-JAVA-%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E3%80%82"><span class="toc-number">2.8.</span> <span class="toc-text">9.讲讲 JAVA 的反射机制。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%BD%A0%E4%BB%AC%E7%BA%BF%E4%B8%8A%E5%BA%94%E7%94%A8%E7%9A%84-JVM-%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%E3%80%82"><span class="toc-number">2.9.</span> <span class="toc-text">10.你们线上应用的 JVM 参数有哪些。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-g1-%E5%92%8C-cms-%E5%8C%BA%E5%88%AB-%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%E5%92%8C%E5%93%8D%E5%BA%94%E4%BC%98%E5%85%88%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E9%80%89%E6%8B%A9%E3%80%82"><span class="toc-number">2.10.</span> <span class="toc-text">11.g1 和 cms 区别,吞吐量优先和响应优先的垃圾收集器选择。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86"><span class="toc-number">3.</span> <span class="toc-text">3.开源框架知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E8%AE%B2%E8%AE%B2-tomcat-%E7%BB%93%E6%9E%84%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%85%B6%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%B5%81%E7%A8%8B%E3%80%82"><span class="toc-number">3.1.</span> <span class="toc-text">1.简单讲讲 tomcat 结构，以及其类加载器流程。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-tomcat-%E5%A6%82%E4%BD%95%E8%B0%83%E4%BC%98%EF%BC%8C%E6%B6%89%E5%8F%8A%E5%93%AA%E4%BA%9B%E5%8F%82%E6%95%B0%E3%80%82"><span class="toc-number">3.2.</span> <span class="toc-text">2.tomcat 如何调优，涉及哪些参数。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%AE%B2%E8%AE%B2-Spring-%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%E3%80%82"><span class="toc-number">3.3.</span> <span class="toc-text">3.讲讲 Spring 加载流程。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%AE%B2%E8%AE%B2-Spring-%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7%E3%80%82"><span class="toc-number">3.4.</span> <span class="toc-text">4.讲讲 Spring 事务的传播属性。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Spring-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E7%9A%84%E3%80%82"><span class="toc-number">3.5.</span> <span class="toc-text">5.Spring 如何管理事务的。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Spring-%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE%E4%BA%8B%E5%8A%A1%EF%BC%88%E5%85%B7%E4%BD%93%E8%AF%B4%E5%87%BA%E4%B8%80%E4%BA%9B%E5%85%B3%E9%94%AE%E7%9A%84-xml-%E5%85%83%E7%B4%A0%EF%BC%89%E3%80%82"><span class="toc-number">3.6.</span> <span class="toc-text">6.Spring 怎么配置事务（具体说出一些关键的 xml 元素）。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-Spring-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E9%9D%9E%E5%8D%95%E4%BE%8B%E6%B3%A8%E5%85%A5%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F%E5%AE%83%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F%E5%BE%AA%E7%8E%AF%E6%B3%A8%E5%85%A5%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8C-aop-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8C%E8%AF%B4%E8%AF%B4-aop-%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E6%9C%AF%E8%AF%AD%EF%BC%8C%E5%AE%83%E4%BB%AC%E6%98%AF%E6%80%8E%E4%B9%88%E7%9B%B8%E4%BA%92%E5%B7%A5%E4%BD%9C%E7%9A%84%E3%80%82"><span class="toc-number">3.7.</span> <span class="toc-text">7.说说你对 Spring 的理解，非单例注入的原理？它的生命周期？循环注入的原理， aop 的实现原理，说说 aop 中的几个术语，它们是怎么相互工作的。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Springmvc-%E4%B8%AD-DispatcherServlet-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E3%80%82"><span class="toc-number">3.8.</span> <span class="toc-text">8.Springmvc 中 DispatcherServlet 初始化过程。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-springMVC%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.9.</span> <span class="toc-text">9.springMVC的执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%BA%8B%E7%89%A9%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.10.</span> <span class="toc-text">10.事物的理解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.</span> <span class="toc-text">4.操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Linux-%E7%B3%BB%E7%BB%9F%E4%B8%8B%E4%BD%A0%E5%85%B3%E6%B3%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%EF%BC%8C%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E3%80%82"><span class="toc-number">4.1.</span> <span class="toc-text">1.Linux 系统下你关注过哪些内核参数，说说你知道的。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Linux-%E4%B8%8B-IO-%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E5%90%AB%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%E3%80%82"><span class="toc-number">4.2.</span> <span class="toc-text">2.Linux 下 IO 模型有几种，各自的含义是什么。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-epoll-%E5%92%8C-poll-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">4.3.</span> <span class="toc-text">3.epoll 和 poll 有什么区别。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%B9%B3%E6%97%B6%E7%94%A8%E5%88%B0%E5%93%AA%E4%BA%9B-Linux-%E5%91%BD%E4%BB%A4%E3%80%82"><span class="toc-number">4.4.</span> <span class="toc-text">4.平时用到哪些 Linux 命令。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%94%A8%E4%B8%80%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%80%E5%90%8E%E4%BA%94%E8%A1%8C%E3%80%82"><span class="toc-number">4.5.</span> <span class="toc-text">5.用一行命令查看文件的最后五行。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%94%A8%E4%B8%80%E8%A1%8C%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84-java-%E8%BF%9B%E7%A8%8B%E3%80%82"><span class="toc-number">4.6.</span> <span class="toc-text">6.用一行命令输出正在运行的 java 进程。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BB%8B%E7%BB%8D%E4%B8%8B%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%E3%80%82"><span class="toc-number">4.7.</span> <span class="toc-text">7.介绍下你理解的操作系统中线程切换过程。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">4.8.</span> <span class="toc-text">8.进程和线程的区别。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">5.多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E3%80%82"><span class="toc-number">5.1.</span> <span class="toc-text">1.多线程的几种实现方式，什么是线程安全。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-volatile-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BD%9C%E7%94%A8%EF%BC%8C%E8%83%BD%E4%BB%A3%E6%9B%BF%E9%94%81%E4%B9%88%E3%80%82"><span class="toc-number">5.2.</span> <span class="toc-text">2.volatile 的原理，作用，能代替锁么。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%94%BB%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%8A%B6%E6%80%81%E5%9B%BE%E3%80%82"><span class="toc-number">5.3.</span> <span class="toc-text">3.画一个线程的生命周期状态图。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-sleep-%E5%92%8C-wait-%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">5.4.</span> <span class="toc-text">4.sleep 和 wait 的区别。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Lock-%E4%B8%8E-Synchronized-%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">5.5.</span> <span class="toc-text">5.Lock 与 Synchronized 的区别。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-synchronized-%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E8%A7%A3%E9%87%8A%E4%BB%A5%E4%B8%8B%E5%90%8D%E8%AF%8D%EF%BC%9A%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%8C%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%8C%E5%81%8F%E5%90%91%E9%94%81%EF%BC%8C%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%8C%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%8C%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%8C%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E6%82%B2%E8%A7%82%E9%94%81%E3%80%82"><span class="toc-number">5.6.</span> <span class="toc-text">6.synchronized 的原理是什么，解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%AD%90%E7%B1%BB%EF%BC%8C%E4%BB%96%E4%BB%AC%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E3%80%82"><span class="toc-number">5.7.</span> <span class="toc-text">7.用过哪些原子类，他们的原理是什么。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%94%A8%E8%BF%87%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%97%EF%BC%8CnewCache-%E5%92%8C-newFixed-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%96%E4%BB%AC%E7%9A%84%E5%8E%9F%E7%90%86%E7%AE%80%E5%8D%95%E6%A6%82%E6%8B%AC%E4%B8%8B%EF%BC%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E5%90%AB%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%AF%94%E5%A6%82-coreSize%EF%BC%8Cmaxsize-%E7%AD%89%E3%80%82"><span class="toc-number">5.8.</span> <span class="toc-text">8.用过线程池吗，newCache 和 newFixed 有什么区别，他们的原理简单概括下，构造函数的各个参数的含义是什么，比如 coreSize，maxsize 等。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%85%B3%E9%97%AD%E6%96%B9%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E3%80%82"><span class="toc-number">5.9.</span> <span class="toc-text">9.线程池的关闭方式有几种，各自的区别是什么。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%81%87%E5%A6%82%E6%9C%89%E4%B8%80%E4%B8%AA%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%A5%E5%8F%A3%EF%BC%8C%E6%9C%89%E5%BE%88%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%8E%BB%E8%B0%83%E7%94%A8%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E7%8E%B0%E5%9C%A8%E8%A7%84%E5%AE%9A%E6%AF%8F%E7%A7%92%E9%92%9F%E6%9C%80%E5%A4%9A%E6%9C%89-10-%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%97%B6%E8%B0%83%E7%94%A8%E5%AE%83%EF%BC%8C%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E3%80%82"><span class="toc-number">5.10.</span> <span class="toc-text">10.假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有 10 个线程同时调用它，如何做到。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-spring-%E7%9A%84-controller-%E6%98%AF%E5%8D%95%E4%BE%8B%E8%BF%98%E6%98%AF%E5%A4%9A%E4%BE%8B%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E7%9A%84%E5%AE%89%E5%85%A8%E3%80%82"><span class="toc-number">5.11.</span> <span class="toc-text">11.spring 的 controller 是单例还是多例，怎么保证并发的安全。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E7%94%A8%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%8C%89%E9%A1%BA%E5%BA%8F%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B0-abc-%E4%B8%89%E4%B8%AA%E5%AD%97%E6%AF%8D%EF%BC%8C%E6%AF%94%E5%A6%82-abcabcabc%E3%80%82"><span class="toc-number">5.12.</span> <span class="toc-text">12.用三个线程按顺序循环打印 abc 三个字母，比如 abcabcabc。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-ThreadLocal-%E7%94%A8%E8%BF%87%E4%B9%88%EF%BC%8C%E7%94%A8%E9%80%94%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%E3%80%82"><span class="toc-number">5.13.</span> <span class="toc-text">13.ThreadLocal 用过么，用途是什么，原理是什么，用的时候要注意什么。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84%E9%93%BE%E8%A1%A8%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%81%9A%E3%80%82"><span class="toc-number">5.14.</span> <span class="toc-text">14.如果让你实现一个并发安全的链表，你会怎么做。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%97%A0%E9%94%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E4%BB%96%E4%BB%AC%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%E3%80%82"><span class="toc-number">5.15.</span> <span class="toc-text">15.有哪些无锁数据结构，他们实现的原理是什么。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E8%AE%B2%E8%AE%B2-java-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84-wait-%E5%92%8C-notify%E3%80%82"><span class="toc-number">5.16.</span> <span class="toc-text">16.讲讲 java 同步机制的 wait 和 notify。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A6%82%E6%9E%9C%E7%BA%BF%E7%A8%8B%E6%8C%82%E4%BD%8F%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%E3%80%82"><span class="toc-number">5.17.</span> <span class="toc-text">17.多线程如果线程挂住了怎么办。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-countdowlatch-%E5%92%8C-cyclicbarrier-%E7%9A%84%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%E5%92%8C%E7%94%A8%E6%B3%95%EF%BC%8C%E4%BB%A5%E5%8F%8A%E7%9B%B8%E4%BA%92%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%88%AB%E3%80%82"><span class="toc-number">5.18.</span> <span class="toc-text">18.countdowlatch 和 cyclicbarrier 的内部原理和用法，以及相互之间的差别。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E4%BD%BF%E7%94%A8-synchronized-%E4%BF%AE%E9%A5%B0%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">5.19.</span> <span class="toc-text">19.使用 synchronized 修饰静态方法和非静态方法有什么区别。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E7%AE%80%E8%BF%B0-ConcurrentLinkedQueue-LinkedBlockingQueue-%E7%9A%84%E7%94%A8%E5%A4%84%E5%92%8C%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84%E3%80%82"><span class="toc-number">5.20.</span> <span class="toc-text">20.简述 ConcurrentLinkedQueue LinkedBlockingQueue 的用处和不同之处。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E9%9D%9E%E5%B8%B8%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%8F%AF%E8%83%BD%E6%98%AF%E4%B8%8D%E5%90%8C%E6%9C%BA%E5%99%A8%EF%BC%89%EF%BC%8C%E7%9B%B8%E4%BA%92%E4%B9%8B%E9%97%B4%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85%E5%8D%8F%E8%B0%83%EF%BC%8C%E6%89%8D%E8%83%BD%E5%AE%8C%E6%88%90%E6%9F%90%E7%A7%8D%E5%B7%A5%E4%BD%9C%EF%BC%8C%E9%97%AE%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E8%BF%99%E7%A7%8D%E5%8D%8F%E8%B0%83%E6%96%B9%E6%A1%88%E3%80%82"><span class="toc-number">5.21.</span> <span class="toc-text">21.非常多个线程（可能是不同机器），相互之间需要等待协调，才能完成某种工作，问怎么设计这种协调方案。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-http1-0-%E5%92%8C-http1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">5.22.</span> <span class="toc-text">22.http1.0 和 http1.1 有什么区别。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E8%A6%81-4-%E6%AC%A1-%E5%A6%82%E6%9E%9C%E6%8F%A1%E6%89%8B%E5%8F%AA%E6%9C%89%E4%B8%A4%E6%AC%A1%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E3%80%82"><span class="toc-number">5.23.</span> <span class="toc-text">23.TCP 三次握手和四次挥手的流程，为什么断开连接要 4 次,如果握手只有两次，会出现什么。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-TIME-WAIT-%E5%92%8C-CLOSE-WAIT-%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">5.24.</span> <span class="toc-text">24.TIME_WAIT 和 CLOSE_WAIT 的区别。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E5%87%A0%E7%A7%8D-HTTP-%E5%93%8D%E5%BA%94%E7%A0%81%EF%BC%8C%E6%AF%94%E5%A6%82-200-302-404%E3%80%82"><span class="toc-number">5.25.</span> <span class="toc-text">25.说说你知道的几种 HTTP 响应码，比如 200, 302, 404。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E5%BD%93%E4%BD%A0%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E9%93%BE%E6%8E%A5%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E5%B7%A5%E4%BD%9C%E6%AD%A5%E9%AA%A4%E3%80%82"><span class="toc-number">5.26.</span> <span class="toc-text">26.当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-TCP-x2F-IP-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%8C%E8%AF%B4%E8%AF%B4-TCP-%E5%A4%B4%E7%9A%84%E7%BB%93%E6%9E%84%E3%80%82"><span class="toc-number">5.27.</span> <span class="toc-text">27.TCP&#x2F;IP 如何保证可靠性，说说 TCP 头的结构。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E3%80%82"><span class="toc-number">5.28.</span> <span class="toc-text">28.如何避免浏览器缓存。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E7%AE%80%E8%BF%B0-Http-%E8%AF%B7%E6%B1%82-get-%E5%92%8C-post-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%8C%85%E6%A0%BC%E5%BC%8F%E3%80%82"><span class="toc-number">5.29.</span> <span class="toc-text">29.简述 Http 请求 get 和 post 的区别以及数据包格式。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E7%AE%80%E8%BF%B0-HTTP-%E8%AF%B7%E6%B1%82%E7%9A%84%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%E3%80%82"><span class="toc-number">5.30.</span> <span class="toc-text">30.简述 HTTP 请求的报文格式。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-HTTPS-%E7%9A%84%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E8%AE%B2%E8%AE%B2%E6%95%B4%E4%B8%AA%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E6%B5%81%E7%A8%8B%E3%80%82"><span class="toc-number">5.31.</span> <span class="toc-text">31.HTTPS 的加密方式是什么，讲讲整个加密解密流程。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E3%80%82"><span class="toc-number">5.32.</span> <span class="toc-text">32.常见的缓存策略有哪些，你们项目中用到了什么缓存系统，如何设计的。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E7%94%A8-java-%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-LRU%E3%80%82"><span class="toc-number">5.33.</span> <span class="toc-text">33.用 java 自己实现一个 LRU。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E4%B8%8B%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%94%AF%E4%B8%80%E5%BA%8F%E5%88%97%E5%8F%B7%E3%80%82"><span class="toc-number">5.34.</span> <span class="toc-text">34.分布式集群下如何做到唯一序列号。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%EF%BC%8C30-%E5%88%86%E9%92%9F%E6%B2%A1%E4%BB%98%E6%AC%BE%E5%B0%B1%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD%E4%BA%A4%E6%98%93%E3%80%82"><span class="toc-number">5.35.</span> <span class="toc-text">35.设计一个秒杀系统，30 分钟没付款就自动关闭交易。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-redis-%E5%92%8C-zookeeper-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%8C%E5%88%86%E5%88%AB%E9%80%82%E7%94%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E3%80%82"><span class="toc-number">5.36.</span> <span class="toc-text">36.如何使用 redis 和 zookeeper 实现分布式锁？有什么区别优缺点，分别适用什么场景。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-%E5%A6%82%E6%9E%9C%E6%9C%89%E4%BA%BA%E6%81%B6%E6%84%8F%E5%88%9B%E5%BB%BA%E9%9D%9E%E6%B3%95%E8%BF%9E%E6%8E%A5%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E3%80%82"><span class="toc-number">5.37.</span> <span class="toc-text">37.如果有人恶意创建非法连接，怎么解决。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E3%80%82"><span class="toc-number">5.38.</span> <span class="toc-text">38.分布式事务的原理，优缺点，如何使用分布式事务。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7-hash%E3%80%82"><span class="toc-number">5.39.</span> <span class="toc-text">39.什么是一致性 hash。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-%E4%BB%80%E4%B9%88%E6%98%AF-restful%EF%BC%8C%E8%AE%B2%E8%AE%B2%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84-restful%E3%80%82"><span class="toc-number">5.40.</span> <span class="toc-text">40.什么是 restful，讲讲你理解的 restful。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%BB%BA%E7%AB%8B%E5%92%8C%E4%BF%9D%E6%8C%81-100w-%E7%9A%84%E9%95%BF%E8%BF%9E%E6%8E%A5%E3%80%82"><span class="toc-number">5.41.</span> <span class="toc-text">41.如何设计建立和保持 100w 的长连接。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%82"><span class="toc-number">5.42.</span> <span class="toc-text">42.如何防止缓存雪崩。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E8%A7%A3%E9%87%8A%E4%BB%80%E4%B9%88%E6%98%AF-MESI-%E5%8D%8F%E8%AE%AE-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7-%E3%80%82"><span class="toc-number">5.43.</span> <span class="toc-text">43.解释什么是 MESI 协议(缓存一致性)。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E5%87%A0%E7%A7%8D-HASH-%E7%AE%97%E6%B3%95%EF%BC%8C%E7%AE%80%E5%8D%95%E7%9A%84%E4%B9%9F%E5%8F%AF%E4%BB%A5%E3%80%82"><span class="toc-number">5.44.</span> <span class="toc-text">44.说说你知道的几种 HASH 算法，简单的也可以。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E4%BB%80%E4%B9%88%E6%98%AF-paxos-%E7%AE%97%E6%B3%95%E3%80%82"><span class="toc-number">5.45.</span> <span class="toc-text">45.什么是 paxos 算法。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E7%BA%BF%E4%B8%8A%E7%B3%BB%E7%BB%9F%E7%AA%81%E7%84%B6%E5%8F%98%E5%BE%97%E5%BC%82%E5%B8%B8%E7%BC%93%E6%85%A2%EF%BC%8C%E4%BD%A0%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98%E3%80%82"><span class="toc-number">5.46.</span> <span class="toc-text">46.线上系统突然变得异常缓慢，你如何查找问题。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%B9%B3%E6%97%B6%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%82"><span class="toc-number">5.47.</span> <span class="toc-text">47.说说你平时用到的设计模式。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-Dubbo-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8C%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E6%B5%81%E8%BD%AC%E7%9A%84%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E9%9B%86%E7%BE%A4%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%8C%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%E3%80%82%E9%87%8D%E8%AF%95%E8%BD%AC%E5%8F%91%EF%BC%8C%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E7%9A%84%E7%AD%96%E7%95%A5%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%E3%80%82"><span class="toc-number">5.48.</span> <span class="toc-text">48.Dubbo 的原理，数据怎么流转的，怎么实现集群，负载均衡，服务注册和发现。重试转发，快速失败的策略是怎样的。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-%E4%B8%80%E6%AC%A1-RPC-%E8%AF%B7%E6%B1%82%E7%9A%84%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E3%80%82"><span class="toc-number">5.49.</span> <span class="toc-text">49.一次 RPC 请求的流程是什么。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50-%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%94%A8%E9%80%94%E5%92%8C%E6%84%8F%E4%B9%89%E3%80%82"><span class="toc-number">5.50.</span> <span class="toc-text">50.异步模式的用途和意义。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E7%BC%96%E7%A8%8B%E4%B8%AD%E8%87%AA%E5%B7%B1%E9%83%BD%E6%80%8E%E4%B9%88%E8%80%83%E8%99%91%E4%B8%80%E4%BA%9B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E7%9A%84%EF%BC%8C%E6%AF%94%E5%A6%82%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E3%80%82"><span class="toc-number">5.51.</span> <span class="toc-text">51.编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%AB%99%E4%B8%AD%E7%9A%84%E2%80%9C%E7%A7%81%E4%BF%A1%E2%80%9D%E5%8A%9F%E8%83%BD%EF%BC%8C%E8%A6%81%E6%B1%82%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%81%E5%8F%AF%E6%89%A9%E5%B1%95%E7%AD%89%E7%AD%89%E3%80%82-%E7%94%BB%E4%B8%80%E4%B8%8B%E6%9E%B6%E6%9E%84%E5%9B%BE%E3%80%82"><span class="toc-number">5.52.</span> <span class="toc-text">52.设计一个社交网站中的“私信”功能，要求高并发、可扩展等等。 画一下架构图。</span></a></li></ol></li></ol></div></div><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/zzhBlog.github.io/img/avatar.jpg" onerror="this.onerror=null;this.src='/zzhBlog.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">郑 则弘</div><div class="author-info__description"></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/chenxz21/bcxm" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">微信号: zzh_impl</div></div></div></div></main><footer id="footer" style="background: #FFFFFF"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 郑 则弘</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/chenxz21/hexo-theme-bcxm">Bcxm</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/zzhBlog.github.io/js/utils.js"></script><script src="/zzhBlog.github.io/js/main.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script type="text/javascript" src="https://fastly.jsdelivr.net/npm/leancloud-storage@4.10.0/dist/av-min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>